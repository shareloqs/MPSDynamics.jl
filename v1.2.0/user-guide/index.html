<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · MPSDynamics.jl</title><meta name="title" content="User Guide · MPSDynamics.jl"/><meta property="og:title" content="User Guide · MPSDynamics.jl"/><meta property="twitter:title" content="User Guide · MPSDynamics.jl"/><meta name="description" content="Documentation for MPSDynamics.jl."/><meta property="og:description" content="Documentation for MPSDynamics.jl."/><meta property="twitter:description" content="Documentation for MPSDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MPSDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>User Guide</a><ul class="internal"><li><a class="tocitem" href="#Initial-State"><span>Initial State</span></a></li><li><a class="tocitem" href="#Hamiltonian"><span>Hamiltonian</span></a></li><li><a class="tocitem" href="#Observables"><span>Observables</span></a></li><li><a class="tocitem" href="#Time-Evolution"><span>Time-Evolution</span></a></li><li><a class="tocitem" href="#Data-Storage"><span>Data Storage</span></a></li></ul></li><li><a class="tocitem" href="../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../examples/puredephasing/">Pure-Dephasing</a></li><li><a class="tocitem" href="../examples/timedep/">Time-dependent Hamiltonian</a></li><li><a class="tocitem" href="../examples/anderson-model/">The Anderson Impurity Model</a></li><li><a class="tocitem" href="../examples/bath-observables/">Inspecting the bath by undoing the chain mapping</a></li><li><a class="tocitem" href="../examples/protontransfer/">Proton Transfer Model</a></li><li><a class="tocitem" href="../examples/tailored_sd/">Tailoring the Spectral Density</a></li></ul></li><li><a class="tocitem" href="../convergence/">Convergence checks</a></li><li><a class="tocitem" href="../theory/">Theoretical Background</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Guide</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Guide"><a class="docs-heading-anchor" href="#User-Guide">User Guide</a><a id="User-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-Guide" title="Permalink"></a></h1><p>Here we explain the different steps to perform a simulation.</p><p>Examples with detailed explanations can be found in the <code>Examples</code> section.</p><h2 id="Initial-State"><a class="docs-heading-anchor" href="#Initial-State">Initial State</a><a id="Initial-State-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-State" title="Permalink"></a></h2><p>The initial many-body state of the {System + Environment} can be described easily as <a href="#Matrix-Product-States">Matrix Product States</a> (MPS) or <a href="#Tree-Tensor-Networks">Tree Tensor Networks</a> (TTN) state (e.g. when a system is coupled to several environments).</p><h3 id="Matrix-Product-States"><a class="docs-heading-anchor" href="#Matrix-Product-States">Matrix Product States</a><a id="Matrix-Product-States-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Product-States" title="Permalink"></a></h3><p>A MPS can be initialized with several methods.</p><p>The <a href="../methods/#MPSDynamics.productstatemps"><code>productstatemps</code></a> method enables  to instantiate arbitrary MPS of fixed uniform bond dimension with non-uniform physical dimensions. The individual states of the MPS sites can be provided by setting state to a list of column vectors.  Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state.  Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied. The gauge of the MPS can also be set using a keyword argument.</p><pre><code class="language-julia hljs">julia&gt; ψ = unitcol(1,2) # system initial state

julia&gt; d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1 

julia&gt; cpars = chaincoeffs_ohmic(N, α, s) # chain coefficient for an Ohmic spectral density

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars)

julia&gt; A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ&gt;|Vacuum&gt;</code></pre><p>Alternatively, a chain with a specified number of excitation localised on one site, or delocalized accross several sites can be generated with <a href="../methods/#MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}"><code>MPSDynamics.chainmps</code></a>.</p><p>Random MPS can also be generated with the <a href="../methods/#MPSDynamics.randmps"><code>randmps</code></a> method.</p><p>For the case of fermionic states (which need to be anti-symmetrized), the <a href="../methods/#MPSDynamics.electronkmps"><code>MPSDynamics.electronkmps</code></a> method generate an MPS for an electron with momentum <code>k</code>, and the <a href="../methods/#MPSDynamics.electron2kmps"><code>MPSDynamics.electron2kmps</code></a> generate an MPS with 2 electrons in k-states <code>k1</code> and <code>k2</code>.</p><h3 id="Tree-Tensor-Networks"><a class="docs-heading-anchor" href="#Tree-Tensor-Networks">Tree Tensor Networks</a><a id="Tree-Tensor-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Tensor-Networks" title="Permalink"></a></h3><p>TTN are a generalization of MPS that allows more ramifications to the one dimensional shape of the MSP. This is useful when, for instance, a system is interacting with more than two environments. Tensors of <code>TreeNetwork</code> are usually referred as nodes, while the first node, represented as the leftmost node is called the head node. The Tree structure is built such that a node has always one parent leg pointing to the left and its child legs pointing to the right. Most of the methods for MPS states are overloaded for <code>TreeNetwork</code>. For example, the <a href="../methods/#MPSDynamics.productstatemps"><code>productstatemps</code></a> method tolerates also TTN state and a simple <code>TreeNetwork</code> with only one branch can be initialized in the same way than with MPS.</p><pre><code class="language-julia hljs">julia&gt; ψ = unitcol(1,2)

julia&gt; d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1

julia&gt; cpars = chaincoeffs_ohmic(N, α, s)

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars, tree=true)

julia&gt; A = productstatemps(H.tree, physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # tree-MPS representation of |ψ&gt;|Vacuum&gt;</code></pre><p>Building a specific tree-MPO such as <a href="../methods/#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a> adds no conceptual complexity and MPS methods have the option to built it as a <code>TreeNetwork</code>.</p><h2 id="Hamiltonian"><a class="docs-heading-anchor" href="#Hamiltonian">Hamiltonian</a><a id="Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian" title="Permalink"></a></h2><p>In order to perform time evolution and have access to the dynamics of the many-body state a Hamiltonian needs to be specified in the form of a Matrix Product Operator (MPO) of as a tree tensor network. Either way, this can be done by using a <a href="#Build-in-Hamiltonian">Build-in Hamiltonian</a>, <a href="#Convert-a-MPO-from-ITensor">Convert a MPO from ITensor</a>, or creating a <a href="#Tailored-MPO">Tailored MPO</a>.</p><p>In the context of Open Quantum Systems, custom chain coefficients for the environment can be generated for finite temperature simulations, and/or user provided spectral densities (SDs).</p><h3 id="Build-in-Hamiltonian"><a class="docs-heading-anchor" href="#Build-in-Hamiltonian">Build-in Hamiltonian</a><a id="Build-in-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Build-in-Hamiltonian" title="Permalink"></a></h3><p>MPSDynamics provides several topical Hamiltonians directly in the form of MPO or Tree Tensor Networks such as the Ising model <a href="../methods/#MPSDynamics.isingmpo-Tuple{Int64}"><code>MPSDynamics.isingmpo</code></a>, the XYZ Hamiltonian <a href="../methods/#MPSDynamics.xyzmpo-Tuple{Int64}"><code>MPSDynamics.xyzmpo</code></a>, the Spin Boson Model <a href="../methods/#MPSDynamics.spinbosonmpo-NTuple{5, Any}"><code>MPSDynamics.spinbosonmpo</code></a>, a spin coupled to two bosonic baths <a href="../methods/#MPSDynamics.twobathspinmpo"><code>MPSDynamics.twobathspinmpo</code></a>, nearest neighbour interactions Hamiltonian <a href="../methods/#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a>, the independent boson model <a href="../methods/#MPSDynamics.ibmmpo-NTuple{4, Any}"><code>MPSDynamics.ibmmpo</code></a>, (non-)uniform tight-binding chain Hamiltonian <a href="../methods/#MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}"><code>MPSDynamics.tightbindingmpo</code></a>.</p><h3 id="Convert-a-MPO-from-ITensor"><a class="docs-heading-anchor" href="#Convert-a-MPO-from-ITensor">Convert a MPO from ITensor</a><a id="Convert-a-MPO-from-ITensor-1"></a><a class="docs-heading-anchor-permalink" href="#Convert-a-MPO-from-ITensor" title="Permalink"></a></h3><p>The method <a href="../methods/#MPSDynamics.MPOtoVector-Tuple{ITensorMPS.MPO}"><code>MPSDynamics.MPOtoVector</code></a> converts an ITensors chain MPO into a form compatible with MPSDynamics.</p><h3 id="Tailored-MPO"><a class="docs-heading-anchor" href="#Tailored-MPO">Tailored MPO</a><a id="Tailored-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#Tailored-MPO" title="Permalink"></a></h3><p>One can also construct MPO tailored to the problem one is interested in. MPOs are fundamentally a lists of rank-4 tensors such that the right bond dimension of the nth tensor must be equal to the left bond dimension of the n+1th tensor; and the dimension of the physical bonds of the nth tensor must be equal to the corresponding physical bond on the MPS.</p><h3 id="Finite-Temperature-and-Custom-SD"><a class="docs-heading-anchor" href="#Finite-Temperature-and-Custom-SD">Finite Temperature and Custom SD</a><a id="Finite-Temperature-and-Custom-SD-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Temperature-and-Custom-SD" title="Permalink"></a></h3><p>In the T-TEDOPA framework (see <a href="../theory/#Theoretical-Background">Theoretical Background</a> for more details) finite temperature simulations are done with an effective pure state description of the system and the environment where the coupling coefficients (or the SD) is temperature-dependent.</p><p>The corresponding chain coefficients for an Ohmic or a user provided spectral density (that can thus in pratice be either at zero or finite temperature) are computed with the <a href="../methods/#MPSDynamics.chaincoeffs_finiteT"><code>chaincoeffs_finiteT</code></a>. This method is based on the <code>ORTHOPOL</code> routines<sup class="footnote-reference"><a id="citeref-Gautschi" href="#footnote-Gautschi">[Gautschi]</a></sup></p><h2 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h2><p>System and environment observables can be computed, as well as system-and-environment &#39;non-local&#39; observables.</p><p>Observables that will be passed to <a href="../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> to have their expectation value computated at each time step are defined with the <a href="../methods/#MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}"><code>OneSiteObservable</code></a> and <a href="../methods/#MPSDynamics.TwoSiteObservable"><code>TwoSiteObservable</code></a>.</p><p>One-site and two-site obsevables work similarly, they need to be given a name, an (pair of) operator(s) and the (list of) site(s) on which they are evaluated.</p><p>For instance one can calculated the average number of excitation in each of the <span>$N$</span> environmental modes</p><pre><code class="language-julia hljs">    ob = OneSiteObservable(&quot;chain mode occupation&quot;, numb(d), (2,N+1))</code></pre><p>It is also possible to measure composite system/environment observables, for example</p><pre><code class="language-julia hljs">    ob = TwoSiteObservable(&quot;SXdisp&quot;, sx, disp(d), [1], collect(2:N+1))</code></pre><p>which measure the correlation between the spin in the x-direction and the displacement of the bath modes.</p><p>Purely environmental &#39;non-local&#39; observables such as </p><pre><code class="language-julia hljs">    ob = TwoSiteObservable(&quot;bath coherence&quot;, crea(d), anih(d), collect(2:N+1), collect(2:N+1))</code></pre><p>that computes all the chain mode coherences <span>$\langle\hat{a}_n^\dagger\hat{a}_{m}\rangle$</span> (and the chain mode occupation when <span>$n = m$</span>).</p><p>We note that if one knows the coherences and populations of all the chain modes, it is then possible to reconstruct the populations of the normal mode environment.</p><h2 id="Time-Evolution"><a class="docs-heading-anchor" href="#Time-Evolution">Time-Evolution</a><a id="Time-Evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Evolution" title="Permalink"></a></h2><p>Simulation are performed when calling the <a href="../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> function where the time-evolution method should be specified.</p><p>The time-evolution methods currently implemented belong to the familly of Time-Dependent Variational Principle (TDVP). The central point of this method, in the modern tensor networks formulation, is that instead of solving the Schrödinger equation and then truncating the MPS representation of the quantum state, one can solve the equations of motion projected into a space of restricted bond dimension.  The major advantage of this method is that it naturally preserves the unitarity of the time evolution and conserves the energy (except in its two-site implementation). Three variants of TDVP are implemented in the <code>MPSDynamics.jl</code> package:</p><ul><li>one-site TDVP (TDVP1): fixed bond dimension, preserves unitarity, conserves energy, scales as <span>$\mathcal{O}(D^2 d^2 w^2 + D^3 dw + D^3 d^2 )$</span> where <span>$D$</span> is the MPS (or TTN) bond dimension, <span>$d$</span> the local dimension, <span>$w$</span> the MPO bond dimension.</li><li>two-site TDVP (TDVP2): adaptive bond dimension, breaks unitarity, scales as <span>$\mathcal{O}(D^2d^3 w^2 + D^3 d^2 w + D^3 d^3 )$</span>.</li><li>adaptive one-site TDVP (DTDVP): adaptive bond dimension, preserves unitarity, conserves energy.</li></ul><p>Local one-site and two-site observables, as well as non-local two-site observables, can be efficiently computed for each time-step of the time-evolution with the three methods.</p><h3 id="One-site-TDVP"><a class="docs-heading-anchor" href="#One-site-TDVP">One-site TDVP</a><a id="One-site-TDVP-1"></a><a class="docs-heading-anchor-permalink" href="#One-site-TDVP" title="Permalink"></a></h3><p>This implementation of the TDVP can be used for MPS and TTN. It performs one-site updates of the tensor network tensors while keeping the bond dimension fixed. Because no reduction of the dimensionality is performed (for instnce by throwing away some simgular values), it naturally preserves unitarity and hence conserves energy. The otherside of the coin is that simulation might be slower because the bond dimension is large at <em>all time</em>.</p><p>The convergence parameter of the simulation is thus the bond dimension <code>D</code>.</p><p>This method can be used with in <a href="../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> with the key word argument <code>method=:TDVP1</code>.</p><h3 id="Two-Site-TDVP"><a class="docs-heading-anchor" href="#Two-Site-TDVP">Two-Site TDVP</a><a id="Two-Site-TDVP-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Site-TDVP" title="Permalink"></a></h3><p>This version of the TDVP evolves two-site tensors than can be split back into two individual site tensors by applying an SVD. The bond dimension between two neighbouring sites can then be truncated to any value <span>$≤ r$</span> by throwing away any singular values that fall below some threshold.  In this way, the MPS bond dimension will grow dynamically throughout the course of the evolution to capture entanglement, as and when it emerges. The truncation entails a loss of unitarity.  Indeed, for a nearest-neighbour Hamiltonian, applying the two-site projector will not entail a projection error, leading to a scheme that is almost identical to TEBD,wherein the error arises solely from the truncation. Furthermore, 2TDVP scales poorly with the local physical dimension, and is known to have issues with long-range interactions.</p><p>The convergence parameter is the threshold of the SVD.</p><p>This method can be used with in <a href="../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> with the key word argument <code>method=:TDVP2</code>.</p><h3 id="Adaptive-One-Site-TDVP"><a class="docs-heading-anchor" href="#Adaptive-One-Site-TDVP">Adaptive One-Site TDVP</a><a id="Adaptive-One-Site-TDVP-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-One-Site-TDVP" title="Permalink"></a></h3><p>Ahead of any time evolution, one computes new bond dimensions of the MPS if the relative rate of change of the TDVP projection error with respect to the bond dimension is larger than a chosen precision <code>p</code>. Then, TDVP1 is performed, using projectors with sub-spaces expanded accordingly, to produce an MPS evolved by one time step with the new,increased, bond dimensions. This version is faster than TDVP1 due to the acceleration gained from having more optimised bond dimensions; the bond update step is cheap and so its cost should not normally outweigh this advantage. However, two things need to be noticed:</p><ul><li>DTDVP can get stuck into local minima from the initial time. If the bond dimension does not change during the time-evolution, consider embeding your MPS in a larger manifold with <a href="../methods/#MPSDynamics.mpsembed!-Tuple{Vector, Int64}"><code>MPSDynamics.mpsembed!</code></a> before time-evolving it.</li><li>For models with analytical solutions that are MPS of a given bond dimension (such as the independent boson model), DTDVP can overshoot the analytical bond dimension because the relative rate of change of the projection error becomes dominated by random numerical fluctuations.</li></ul><p>The convergence parameter is a threshold value <code>p</code> for the rate of change of the projection error with respect to the bond dimension.</p><p>This method can be used with in <a href="../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> with the key word argument <code>method=:DTDVP</code>.</p><h2 id="Data-Storage"><a class="docs-heading-anchor" href="#Data-Storage">Data Storage</a><a id="Data-Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Storage" title="Permalink"></a></h2><p>The data (i.e. observables time-series) is stored in the JLD format which is based on HDF5.</p><p>The HDF5 format is natively supported across many platforms and languages (e.g. <code>Python</code>, or <code>Mathematica</code>).</p><p>For the data to be saved to a file after a run, the keyword argument <code>save=true</code> needs to be used in <code>runsim</code>.</p><p>The directory where the data should be saved can be chosen by setting a path with the <code>savedir</code> keyword argument.</p><p>A <code>plot</code> keyword argument can also be used to choose whether plots for 1D observables will be automatically generated and saved along with the data. </p><p>Loading the data in Julia using the <a href="https://github.com/JuliaIO/JLD.jl"><code>JLD.jl</code></a> package will recover the full type information of the Julia variables that were stored.</p><pre><code class="language-julia hljs">julia&gt; using JLD

julia&gt; dat = load(&quot;filename.jld&quot;)
Dict{String, Any} with 2 entries:
  &quot;parameters&quot; =&gt; Dict{String, Any}(&quot;tmax&quot;=&gt;0.2, &quot;method&quot;=&gt;:DTDVP, &quot;dt&quot;=&gt;0.0005…
  &quot;data&quot;       =&gt; Dict{String, Any}(&quot;bonddims&quot;=&gt;[1 1 … 1 1; 1 2 … 2 2; … ; 1 1 …</code></pre><p>If the data is loaded in an variable <code>dat</code> the structure is the folowing:</p><ul><li>the <code>parameters</code> entry contains a dictionary where all the simulation parameters are stored</li><li>the <code>data</code> entry contains a dictionary where are stored simulation time, the observables and (whenever relevent) the bond dimension of the state at each time steps. </li></ul><pre><code class="language-julia hljs">julia&gt; dat[&quot;parameters&quot;]
Dict{String, Any} with 11 entries:
  &quot;tmax&quot;       =&gt; 0.2
  &quot;method&quot;     =&gt; :DTDVP
  &quot;dt&quot;         =&gt; 0.0005
  &quot;name&quot;       =&gt; &quot;my model&quot;
  &quot;Δ&quot;          =&gt; 0.0
  &quot;β&quot;          =&gt; 0.0186854
  &quot;N&quot;          =&gt; 300.0
  &quot;d&quot;          =&gt; 15.0
  &quot;unid&quot;       =&gt; &quot;Ovzm6&quot;
  &quot;ω0&quot;         =&gt; 0.0
  &quot;convparams&quot; =&gt; 0.0005

julia&gt; dat[&quot;data&quot;]
Dict{String, Any} with 6 entries:
  &quot;bonddims&quot; =&gt; [1 1 … 1 1; 1 2 … 2 2; … ; 1 1 … 7 7; 1 1 … 1 1]
  &quot;sx&quot;       =&gt; [1.0, 0.912818, 0.741759, 0.605797, 0.528792, 0.492497, 0.47976…
  &quot;sz&quot;       =&gt; [0.0, 0.0871825, 0.25824, 0.394201, 0.471207, 0.507503, 0.52023…
  &quot;nchain&quot;   =&gt; [0.0 0.23466 … 1.84319 1.76098; 0.0 0.00231507 … 0.83105 0.9033…
  &quot;sy&quot;       =&gt; [0.0, -0.0133489, -0.0588887, -0.0858181, -0.0759996, -0.048539…
  &quot;times&quot;    =&gt; [0.0, 0.0005, 0.001, 0.0015, 0.002, 0.0025, 0.003, 0.0035, 0.00…
</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Gautschi"><a class="tag is-link" href="#citeref-Gautschi">Gautschi</a><blockquote><p>Gautschi, W. Algorithm 726: ORTHPOL–a package of routines for generating orthogonal polynomials and Gauss-type quadrature rules. ACM Trans. Math. Softw. 20, 21–62 (1994).</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 26 May 2025 14:10">Monday 26 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
