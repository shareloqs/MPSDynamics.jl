<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · MPSDynamics.jl</title><meta name="title" content="Methods · MPSDynamics.jl"/><meta property="og:title" content="Methods · MPSDynamics.jl"/><meta property="twitter:title" content="Methods · MPSDynamics.jl"/><meta name="description" content="Documentation for MPSDynamics.jl."/><meta property="og:description" content="Documentation for MPSDynamics.jl."/><meta property="twitter:description" content="Documentation for MPSDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MPSDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../user-guide/">User Guide</a></li><li><a class="tocitem" href="../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../examples/puredephasing/">Pure-Dephasing</a></li><li><a class="tocitem" href="../examples/timedep/">Time-dependent Hamiltonian</a></li><li><a class="tocitem" href="../examples/anderson-model/">The Anderson Impurity Model</a></li><li><a class="tocitem" href="../examples/bath-observables/">Inspecting the bath by undoing the chain mapping</a></li><li><a class="tocitem" href="../examples/protontransfer/">Proton Transfer Model</a></li><li><a class="tocitem" href="../examples/tailored_sd/">Tailoring the Spectral Density</a></li></ul></li><li><a class="tocitem" href="../convergence/">Convergence checks</a></li><li><a class="tocitem" href="../theory/">Theoretical Background</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Product-State-(MPS)"><span>Matrix Product State (MPS)</span></a></li><li><a class="tocitem" href="#Tree-Tensor-Network-(TTN)"><span>Tree Tensor Network (TTN)</span></a></li><li><a class="tocitem" href="#Measure-and-Obervables"><span>Measure and Obervables</span></a></li><li><a class="tocitem" href="#Models-and-Hamiltonians-(MPO)"><span>Models and Hamiltonians (MPO)</span></a></li><li><a class="tocitem" href="#Chain-Mapping"><span>Chain-Mapping</span></a></li><li><a class="tocitem" href="#Dynamics-propagation-function"><span>Dynamics propagation function</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li><li><a class="tocitem" href="../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-all-methods"><a class="docs-heading-anchor" href="#List-of-all-methods">List of all methods</a><a id="List-of-all-methods-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-all-methods" title="Permalink"></a></h1><h2 id="Matrix-Product-State-(MPS)"><a class="docs-heading-anchor" href="#Matrix-Product-State-(MPS)">Matrix Product State (MPS)</a><a id="Matrix-Product-State-(MPS)-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Product-State-(MPS)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Int64}" href="#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Int64}"><code>MPSDynamics.apply1siteoperator!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply1siteoperator!(A, O, sites::Int)</code></pre><p>Apply an operator O on the MPS A. O is acting on only one site ::Int. The resulting MPS A is the MPS modified by the operator O.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Vector{Int64}}" href="#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Vector{Int64}}"><code>MPSDynamics.apply1siteoperator!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply1siteoperator!(A, O, sites::Vector{Int})</code></pre><p>Apply an operator O on the MPS A. O is acting on several sites ::Vector{Int}. The resulting MPS A is the MPS modified by the operator O.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.applympo!-Tuple{Any, Any}" href="#MPSDynamics.applympo!-Tuple{Any, Any}"><code>MPSDynamics.applympo!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">applympo!(A, H; SVD=false, kwargs...)</code></pre><p>Apply an MPO H on the MPS A. H must have the same number of site than A. The resulting MPS A is the MPS modified by the MPO H. The argument SVD can be set to true if one wants the MPS to recover the same dimensions after having applied the MPO H. Further parameters for the SVD truncation can be added with the kwargs.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}" href="#MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chainmps(N::Int, site::Int, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations on <code>site</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}" href="#MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chainmps(N::Int, sites::Vector{Int}, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal super-position over <code>sites</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.displacedchainmps-Tuple{Vector{Any}, Int64, Int64, Any}" href="#MPSDynamics.displacedchainmps-Tuple{Vector{Any}, Int64, Int64, Any}"><code>MPSDynamics.displacedchainmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displacedchainmps(A::Vector{Any}, N::Int, Nm::Int, γ::Any)</code></pre><p>Given a MPS A, return a MPS B where the <code>Nm</code>-long chain is displaced by <code>γ</code> without displacing the <code>N</code>-long system.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.electron2kmps" href="#MPSDynamics.electron2kmps"><code>MPSDynamics.electron2kmps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with 2 electrons in k-states <code>k1</code> and <code>k2</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.electronkmps" href="#MPSDynamics.electronkmps"><code>MPSDynamics.electronkmps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS for an electron with momentum <code>k</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.elementmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elementmpo(M, el...)</code></pre><p>Return the element of the MPO <code>M</code> for the set of physical states <code>el...</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.elementmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">elementmps(A, el...)</code></pre><p>Return the element of the MPS <code>A</code> for the set of physical states <code>el...</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = chainmps(6, [2,4], 1);

julia&gt; elementmps(A, 1, 2, 1, 1, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 1, 1, 2, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 2, 1, 2, 1, 1)
0.0

julia&gt; elementmps(A, 1, 1, 1, 1, 1, 1)
0.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.entanglemententropy-Tuple{Any}" href="#MPSDynamics.entanglemententropy-Tuple{Any}"><code>MPSDynamics.entanglemententropy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entanglemententropy(A)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal superposition of modes <code>k</code> of a bosonic tight-binding chain.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of mode <code>k</code> of a bosonic tight-binding chain. </p><p><code>chainparams</code> takes the form <code>[e::Vector, t::Vector]</code> where <code>e</code> are the on-site energies and <code>t</code> are the hoppping parameters.</p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{Vector, Int64}" href="#MPSDynamics.mpsembed!-Tuple{Vector, Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsembed!(A::Vector, Dmax::Int)</code></pre><p>Embed MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsleftnorm!" href="#MPSDynamics.mpsleftnorm!"><code>MPSDynamics.mpsleftnorm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsleftnorm!(A::Vector, jq::Int=length(A))</code></pre><p>Left orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsmixednorm!(A::Vector, OC::Int)</code></pre><p>Put MPS <code>A</code> into mixed canonical form with orthogonality centre on site <code>OC</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!" href="#MPSDynamics.mpsrightnorm!"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsrightnorm!(A::Vector, jq::Int=1)</code></pre><p>Right orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.multiply-Tuple{Vector, Vector}" href="#MPSDynamics.multiply-Tuple{Vector, Vector}"><code>MPSDynamics.multiply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiply(M1::Vector, M2::Vector)</code></pre><p>Calculates M1*M2 where M1 and M2 are MPOs</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{Vector}" href="#MPSDynamics.normmps-Tuple{Vector}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normmps(A::Vector; mpsorthog=:None)</code></pre><p>Calculate norm of MPS <code>A</code>.</p><p>Setting <code>mpsorthog</code>=<code>:Right</code>/<code>:Left</code> will calculate the norm assuming right/left canonical form. Setting <code>mpsorthog=OC::Int</code> will cause the norm to be calculated assuming the orthoganility center is on site <code>OC</code>. If mpsorthog is <code>:None</code> the norm will be calculated as an MPS-MPS product.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.orthcentersmps-Tuple{Vector}" href="#MPSDynamics.orthcentersmps-Tuple{Vector}"><code>MPSDynamics.orthcentersmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orthcentersmps(A::Vector)</code></pre><p>Compute the orthoganality centres of MPS <code>A</code>.</p><p>Return value is a list in which each element is the corresponding site tensor of <code>A</code> with the orthogonality centre on that site. Assumes <code>A</code> is right normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{Vector}" href="#MPSDynamics.physdims-Tuple{Vector}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physdims(M)</code></pre><p>Return the physical dimensions of an MPS or MPO <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p>The argument <code>mpsorthog</code> can be used to set the gauge of the resulting MPS.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = unitcol(1,2); d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1

julia&gt; cpars = chaincoeffs_ohmic(N, α, s)

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars)

julia&gt; A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ&gt;|Vacuum&gt;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an <code>N</code>-site MPS with all local Hilbert space dimensions given by <code>d</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randmps(N::Int, d::Int, Dmax::Int, T=Float64)</code></pre><p>Construct a random, <code>N</code>-site, right-normalised MPS with all local Hilbert space dimensions given by <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.randmps-Union{Tuple{N}, Tuple{NTuple{N, Int64}, Int64}, Tuple{NTuple{N, Int64}, Int64, Type{&lt;:Number}}} where N" href="#MPSDynamics.randmps-Union{Tuple{N}, Tuple{NTuple{N, Int64}, Int64}, Tuple{NTuple{N, Int64}, Int64, Type{&lt;:Number}}} where N"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randmps(physdims::Dims{N}, Dmax::Int, T::Type{&lt;:Number} = Float64) where {N}</code></pre><p>Construct a random, right-normalised MPS with local Hilbert space dimensions given by <code>physdims</code> and max bond-dimension given by <code>Dmax</code>. </p><p><code>T</code> specifies the element type, eg. use <code>T=ComplexF64</code> for a complex valued MPS.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.reversempo!-Tuple{Any}" href="#MPSDynamics.reversempo!-Tuple{Any}"><code>MPSDynamics.reversempo!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reversempo!(M)</code></pre><p>Reverse the left and right dimensions of the MPO M. The resulting MPO M is the reversed MPO.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.reversempo-Tuple{Any}" href="#MPSDynamics.reversempo-Tuple{Any}"><code>MPSDynamics.reversempo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reversempo(M)</code></pre><p>Reverse the left and right dimensions of the MPO M.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.reversemps!-Tuple{Any}" href="#MPSDynamics.reversemps!-Tuple{Any}"><code>MPSDynamics.reversemps!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reversemps!(A)</code></pre><p>Reverse the left and right dimensions of the MPS A. The resulting MPS A is the reversed MPS.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.reversemps-Tuple{Any}" href="#MPSDynamics.reversemps-Tuple{Any}"><code>MPSDynamics.reversemps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reversemps(A)</code></pre><p>Reverse the left and right bond-dimensions of the MPS A.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.svdmps-Tuple{Any}" href="#MPSDynamics.svdmps-Tuple{Any}"><code>MPSDynamics.svdmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svdmps(A)</code></pre><p>For a right normalised mps <code>A</code> compute the full svd spectrum for a bipartition at every bond.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reshape-Tuple{Number, Vararg{Any}}" href="#Base.reshape-Tuple{Number, Vararg{Any}}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.reshape(x::Number, dims...)</code></pre><p>Reshape a number <code>x</code> into a tensor with <code>length(dims)</code> legs that must all be of dimension 1</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.svdtrunc-Tuple{Any}" href="#MPSDynamics.svdtrunc-Tuple{Any}"><code>MPSDynamics.svdtrunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)</code></pre><p>Perform a truncated SVD, with maximum number of singular values to keep equal to <code>truncdim</code> or truncating any singular values smaller than <code>truncerr</code>. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.MPOtoVector-Tuple{ITensorMPS.MPO}" href="#MPSDynamics.MPOtoVector-Tuple{ITensorMPS.MPO}"><code>MPSDynamics.MPOtoVector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MPOtoVector(mpo::MPO)</code></pre><p>Convert an ITensors chain MPO into a form compatible with MPSDynamics</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chainprop-Tuple{Any, Any}" href="#MPSDynamics.chainprop-Tuple{Any, Any}"><code>MPSDynamics.chainprop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chainprop(t, cparams)</code></pre><p>Propagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.cosineh-Tuple{Any, Any}" href="#MPSDynamics.cosineh-Tuple{Any, Any}"><code>MPSDynamics.cosineh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cosineh(omega, bet)</code></pre><p>Calculates the hyperbolic cosine function function based on the input parameters,  for the Bogoliubov transformation necessary for the thermofield transformation.</p><p><strong>Arguments</strong></p><ul><li><code>omega::Float64</code>: The frequency parameter.</li><li><code>bet::Float64</code>: The beta parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The result of the modified cosine function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.disp-Tuple{Any, Any, Any}" href="#MPSDynamics.disp-Tuple{Any, Any, Any}"><code>MPSDynamics.disp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">disp(d,ωvib,m)</code></pre><p>Displacement operator  <span>$X = \frac{\sqrt{2}}{2\sqrt{m \omega_{vib}}}(a + a^{\dagger})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.disp-Tuple{Any}" href="#MPSDynamics.disp-Tuple{Any}"><code>MPSDynamics.disp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">disp(d)</code></pre><p>Mass and frequency-weighted displacement operator  <span>$X = \frac{1}{2}(a + a^{\dagger})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.dynamap-NTuple{4, Any}" href="#MPSDynamics.dynamap-NTuple{4, Any}"><code>MPSDynamics.dynamap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dynamap(ps1,ps2,ps3,ps4)</code></pre><p>Calculate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.</p><p><strong>Arguments</strong></p><ul><li><code>ps1</code> : time evolved system density matrix starting from initial state up</li><li><code>ps2</code> : time evolved system density matrix starting from initial state down</li><li><code>ps3</code> : time evolved system density matrix starting from initial state (up + down)/sqrt(2)</li><li><code>ps4</code> : time evolved system density matrix starting from initial state (up - i*down)/sqrt(2)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.eigenchain-Tuple{Any}" href="#MPSDynamics.eigenchain-Tuple{Any}"><code>MPSDynamics.eigenchain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigenchain(cparams; nummodes=nothing)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.endsiteocc-Tuple{Any, Any}" href="#MPSDynamics.endsiteocc-Tuple{Any, Any}"><code>MPSDynamics.endsiteocc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">endsiteocc(t, cparams)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.entropy-Tuple{Any}" href="#MPSDynamics.entropy-Tuple{Any}"><code>MPSDynamics.entropy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">entropy(rho)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.findchainlength" href="#MPSDynamics.findchainlength"><code>MPSDynamics.findchainlength</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findchainlength(T, ωc::Float64, β=Inf)</code></pre><p>Estimate length of chain using universal asymptotic properties of chain mapped environments given the simulation time T, the bath cut-off frequency ωc, and the inverse temperature β.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.findchainlength-Tuple{Any, Vector}" href="#MPSDynamics.findchainlength-Tuple{Any, Vector}"><code>MPSDynamics.findchainlength</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findchainlength(T, cparams::Vector; eps=10^-6, verbose=false)</code></pre><p>Estimate length of chain required for a particular set of chain parameters by calculating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T. The initial number of sites in cparams has to be larger than the findchainlength result.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measurecorrs-Tuple{Any, Vector, Vector}" href="#MPSDynamics.measurecorrs-Tuple{Any, Vector, Vector}"><code>MPSDynamics.measurecorrs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measurecorrs(oper, , e::Vector, t::Vector)</code></pre><p><strong>Parameters</strong></p><p><code>oper</code>: Square matrix (Matrix{Float64}) representing the operator to be transformed. <code>e</code>: Vector (Vector{Float64}) of diagonal (on-site energy) chain coefficients. <code>t</code>: Vector (Vector{Float64}) of off-diagonal (hopping terms) chain coefficients.</p><p><strong>Returns</strong></p><p>Matrix{Float64}: This matrix is the operator <code>oper</code> transformed back from the chain  representation to the representation corresponding to the extended bath. The resulting  operator represents quantities like mode occupations or other properties in the basis  of environmental modes associated with specific frequencies <span>$\omega_i$</span>.</p><p><strong>Description</strong></p><p>This function performs a basis transformation of the operator <code>oper</code>. Specifically,  this transformation reverses the unitary transformation that maps the extended bath Hamiltonian into the chain representation. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measuremodes" href="#MPSDynamics.measuremodes"><code>MPSDynamics.measuremodes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measuremodes(adaga, e=1.0, t=1.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measuremodes-Tuple{Any, Tuple{Int64, Int64}, AbstractArray}" href="#MPSDynamics.measuremodes-Tuple{Any, Tuple{Int64, Int64}, AbstractArray}"><code>MPSDynamics.measuremodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measuremodes(A, chainsection::Tuple{Int64,Int64}, U::AbstractArray)</code></pre><p>for longer chains it can be worth calculating U in advance</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measuremodes-Tuple{Any, Tuple{Int64, Int64}, Vector{Float64}, Vector{Float64}}" href="#MPSDynamics.measuremodes-Tuple{Any, Tuple{Int64, Int64}, Vector{Float64}, Vector{Float64}}"><code>MPSDynamics.measuremodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measuremodes(A, chainsection::Tuple{Int64,Int64}, e::Array{Float64,1}, t::Array{Float64,1})</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measuremodes-Tuple{Any, Vector, Vector}" href="#MPSDynamics.measuremodes-Tuple{Any, Vector, Vector}"><code>MPSDynamics.measuremodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measuremodes(adaga, e::Vector, t::Vector)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.physical_occup-NTuple{6, Any}" href="#MPSDynamics.physical_occup-NTuple{6, Any}"><code>MPSDynamics.physical_occup</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physical_occup(corr_constr, corr_destr, omega, occup, b, M)</code></pre><p>Calculates the physical occupation based on correlation matrices, omega values,  and other parameters. The physical occupation in the original frequency environment is computed by reverting the thermofield transformation.</p><p><strong>Arguments</strong></p><ul><li><code>corr_constr::Matrix{ComplexF64}</code>: The correlation construction matrix.</li><li><code>corr_destr::Matrix{ComplexF64}</code>: The correlation destruction matrix.</li><li><code>omega::Vector{Float64}</code>: The omega values.</li><li><code>occup::Matrix{Float64}</code>: The occupation matrix.</li><li><code>b::Float64</code>: The beta parameter.</li><li><code>M::Int</code>: The number of points for interpolation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The physical occupation values.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.randisometry-Tuple{Type, Int64, Int64}" href="#MPSDynamics.randisometry-Tuple{Type, Int64, Int64}"><code>MPSDynamics.randisometry</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randisometry([T=Float64], dims...)</code></pre><p>Construct a random isometry</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.rmsd-Tuple{Any, Any}" href="#MPSDynamics.rmsd-Tuple{Any, Any}"><code>MPSDynamics.rmsd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rmsd(ob1, ob2)</code></pre><p>Calculate the root mean squared difference between two measurements of an observable over the same time period.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.sineh-Tuple{Any, Any}" href="#MPSDynamics.sineh-Tuple{Any, Any}"><code>MPSDynamics.sineh</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sineh(omega, bet)</code></pre><p>Calculates the hyperbolic sine function function based on the input parameters,  for the Bogoliubov transformation necessary for the thermofield transformation.</p><p><strong>Arguments</strong></p><ul><li><code>omega::Float64</code>: The frequency parameter.</li><li><code>bet::Float64</code>: The beta parameter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The result of the modified cosine function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.therHam-Tuple{Any, Any, Any}" href="#MPSDynamics.therHam-Tuple{Any, Any, Any}"><code>MPSDynamics.therHam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> therHam(psi, site1, site2)</code></pre><p>Calculates Hβ such that ρ = e^(-βH) for some density matrix ρ obatined from tracing out everything outside the range [site1,site2] in the MPS psi</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.thermaloccupations-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.thermaloccupations-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.thermaloccupations</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thermaloccupations(β, cparams...)</code></pre></div></section></article><h2 id="Tree-Tensor-Network-(TTN)"><a class="docs-heading-anchor" href="#Tree-Tensor-Network-(TTN)">Tree Tensor Network (TTN)</a><a id="Tree-Tensor-Network-(TTN)-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Tensor-Network-(TTN)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}" href="#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}"><code>MPSDynamics.addchild!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addchild!(tree::Tree, id::Int)</code></pre><p>Add child to node <code>id</code> of <code>tree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}" href="#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}"><code>MPSDynamics.addchildren!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addchildren!(tree::Tree, id::Int, n::Int)</code></pre><p>Add <code>n</code> children to node <code>id</code> of <code>tree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}" href="#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}"><code>MPSDynamics.findchild</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findchild(node::TreeNode, id::Int)</code></pre><p>Return integer corresponding to the which number child site <code>id</code> is of <code>node</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.randtree-Tuple{Int64, Int64}" href="#MPSDynamics.randtree-Tuple{Int64, Int64}"><code>MPSDynamics.randtree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randtree(numnodes::Int, maxdegree::Int)</code></pre><p>Construct a random tree with <code>nummodes</code> modes and max degree <code>maxdegree</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Int64}" href="#MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Int64}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(net::TreeNetwork, O, id::Int)</code></pre><p>For a Tree, compute the local expectation value of a one-site operator O for site id.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(net::TreeNetwork, O, sites::Tuple{Int,Int})</code></pre><p>For a Tree, compute the local expectation value of a one-site operator O for the specified site range.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure2siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure2siteoperator(net::TreeNetwork, O1, O2, sites::Tuple{Int,Int})</code></pre><p>For a Tree, compute the local expectation value of two one-site operators O1 and O2 for the specified site range.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.bonddims-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.bonddims-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.bonddims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bonddims(A::TreeNetwork)</code></pre><p>Return the bon-dimension of a tree-MPS <code>A</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsembed!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsembed(A::TreeNetwork, Dmax::Int)</code></pre><p>Embed tree-MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsmixednorm!(A::TreeNetwork, id::Int)</code></pre><p>Normalise tree-MPS <code>A</code> such that orthogonality centre is on site <code>id</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsmoveoc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsmoveoc!(A::TreeNetwork, id::Int)</code></pre><p>Move the orthogonality centre of right normalised tree-MPS <code>A</code> to site <code>id</code>.</p><p>This function will be more efficient than using <code>mpsmixednorm!</code> if the tree-MPS is already right-normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsrightnorm!(A::TreeNetwork)</code></pre><p>When applied to a tree-MPS, right normalise towards head-node.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsshiftoc!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mpsshiftoc!(A::TreeNetwork, newhd::Int)</code></pre><p>Shift the orthogonality centre by one site, setting new head-node <code>newhd</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normmps(net::TreeNetwork; mpsorthog=:None)</code></pre><p>When applied to a tree-MPS <code>mpsorthog=:Left</code> is not defined.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.physdims-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">physdims(M::TreeNetwork)</code></pre><p>Return the physical dimensions of a tree-MPS or tree-MPO <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">productstatemps(tree_::Tree, physdims::Dims, Dmax::Int=1; state=:Vacuum)</code></pre><p>Return a tree-MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = unitcol(1,2); d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1

julia&gt; cpars = chaincoeffs_ohmic(N, α, s)

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars, tree=true)

julia&gt; A = productstatemps(H.tree, physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # tree-MPS representation of |ψ&gt;|Vacuum&gt;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randmps(tree::Tree, physdims, Dmax::Int, T::Type{&lt;:Number} = Float64)</code></pre><p>Construct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by <code>Dmax</code>.</p><p>The local Hilbert space dimensions are specified by physdims which can either be of type <code>Dims{length(tree)}</code>, specifying the dimension of each site, or of type <code>Int</code>, in which case the same local dimension is used for every site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.tdvp1sweep!-Tuple{Any, MPSDynamics.TreeNetwork, MPSDynamics.TreeNetwork, Vector, Int64}" href="#MPSDynamics.tdvp1sweep!-Tuple{Any, MPSDynamics.TreeNetwork, MPSDynamics.TreeNetwork, Vector, Int64}"><code>MPSDynamics.tdvp1sweep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tdvp1sweep!(dt, A::TreeNetwork, M::TreeNetwork, F::Vector, id::Int; verbose=false, kwargs...)</code></pre><p>Propagates the tree-MPS A with the tree-MPO M following the 1-site TDVP method. The sweep is done back and forth with a time step dt/2. F represents the merged left and right parts of the site being propagated.  </p></div></section></article><h2 id="Measure-and-Obervables"><a class="docs-heading-anchor" href="#Measure-and-Obervables">Measure and Obervables</a><a id="Measure-and-Obervables-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-and-Obervables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}" href="#MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}"><code>MPSDynamics.OneSiteObservable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneSiteObservable(name,op,sites)</code></pre><p>Computes the local expectation value of the one-site operator <code>op</code> on the specified sites. Used to define one-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.OneSiteObservable-Tuple{Any, Any}" href="#MPSDynamics.OneSiteObservable-Tuple{Any, Any}"><code>MPSDynamics.OneSiteObservable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneSiteObservable(name,op)</code></pre><p>Computes the local expectation value of the one-site operator <code>op</code> on the every site. Used to define one-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.RhoReduced" href="#MPSDynamics.RhoReduced"><code>MPSDynamics.RhoReduced</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RhoReduced(name,sites)</code></pre><p>Computes the reduced density matrix on the sites <code>sites</code> which can be either a single site or a tuple of two sites. Used to define reduced density matrices that are obs and convobs parameters for the <code>runsim</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.TwoSiteObservable" href="#MPSDynamics.TwoSiteObservable"><code>MPSDynamics.TwoSiteObservable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwoSiteObservable(name,op1,op2,sites1=nothing,sites2=nothing)</code></pre><p>Computes the local expectation value of operators <code>op1</code> and <code>op2</code> where <code>op1</code> acts on sites1 and <code>op2</code> acts on sites2. Used to define several-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any, OneSiteObservable}" href="#MPSDynamics.measure-Tuple{Any, OneSiteObservable}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(A, O; kwargs...)</code></pre><p>Measure observable <code>O</code> on mps state <code>A</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Vector, Vector}" href="#MPSDynamics.measure-Tuple{Vector, Vector}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> measure(A::Vector, Os::Vector; kwargs...)</code></pre><p>Caculate expectation of Os on MPS A.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Int64}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Int64}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(A::Vector, O, site::Int)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for a single site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(A::Vector, O, chainsection::Tuple{Int64,Int64})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for a chainsection.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(A::Vector, O, sites::Vector{Int})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if it is specified.</p><p>For calculating operators on single sites this will be more efficient if the site is on the left of the mps.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure1siteoperator(A::Vector, O)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}" href="#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> measure2siteoperator(A::Vector, M1, M2, j1, j2)</code></pre><p>Caculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Vector{Int64}, Vector{Int64}}" href="#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Vector{Int64}, Vector{Int64}}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> measure2siteoperator(A::Vector, M1, M2, sites1::Vector{Int}, sites2::Vector{Int})</code></pre><p>Caculate expectation of M1*M2 where M1 acts on sites1 and M2 acts on sites2, assumes A is right normalised.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measurempo-Tuple{Vector, Vector, Tuple{Int64, Int64}}" href="#MPSDynamics.measurempo-Tuple{Vector, Vector, Tuple{Int64, Int64}}"><code>MPSDynamics.measurempo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measurempo(A::Vector, M::Vector, sites::Tuples{Int,Int})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of the MPO M on specified sites.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measurempo-Tuple{Vector, Vector}" href="#MPSDynamics.measurempo-Tuple{Vector, Vector}"><code>MPSDynamics.measurempo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measurempo(A::Vector, M::Vector)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of the MPO M on every site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.rhoreduced_1site" href="#MPSDynamics.rhoreduced_1site"><code>MPSDynamics.rhoreduced_1site</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> rhoreduced_1site(A::Vector, site::Int=1)</code></pre><p>Caculate the reduced density matrix of the MPS A at the specified site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.rhoreduced_2sites-Tuple{Vector, Tuple{Int64, Int64}}" href="#MPSDynamics.rhoreduced_2sites-Tuple{Vector, Tuple{Int64, Int64}}"><code>MPSDynamics.rhoreduced_2sites</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> rhoreduced_2sites(A::Vector, site::Tuple{Int, Int})</code></pre><p>Caculate the reduced density matrix of the MPS A of two neigbour sites. The resulting dimensions will be the four physical dimensions in total,  corresponding to the dimensions  of the two sites</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any, FockError}" href="#MPSDynamics.measure-Tuple{Any, FockError}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure(A, obs::FockError; t=0, kwargs...)</code></pre><p>Return the measure of the observable obs on the MPS A. </p></div></section></article><h2 id="Models-and-Hamiltonians-(MPO)"><a class="docs-heading-anchor" href="#Models-and-Hamiltonians-(MPO)">Models and Hamiltonians (MPO)</a><a id="Models-and-Hamiltonians-(MPO)-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-Hamiltonians-(MPO)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}" href="#MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_ohmic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chaincoeffs_ohmic(N, α, s; ωc=1, soft=false)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for an Harmonic bath at zero temperature with a power law spectral density given by:</p><p>soft cutoff: <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s \exp(-ω/ω_c)$</span> </p><p>hard cutoff: <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span></p><p>The coefficients parameterise the chain Hamiltonian</p><p><span>$H = H_S + c_0 A_S⊗B_0+\sum_{i=0}^{N-1}t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span></p><p>which is unitarily equivalent (before the truncation to <code>N</code> sites) to</p><p><span>$H = H_S + A_S⊗\int_0^∞dω\sqrt{J(ω)}B_ω + \int_0^∞dωωb_ω^\dagger b_ω$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.correlatedenvironmentmpo-Tuple{Vector, Int64, Int64}" href="#MPSDynamics.correlatedenvironmentmpo-Tuple{Vector, Int64, Int64}"><code>MPSDynamics.correlatedenvironmentmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correlatedenvironmentmpo(R::Vector, Nm::Int, d::Int; chainparams, fnamecc::String, s=1, α=1, ωc=1, c_phonon=1, β=&quot;inf&quot;, issoft=false)</code></pre><p>Generate a MPO for a one-dimensional bosonic bath spatially correlated to a multi-component system </p><p><span>$H_B + H_{int} = \int_{-∞}^{+∞} dk ω_k b_k^\dagger b_k + ∑_j \int_{-∞}^{+∞}dk \sqrt{J(k)}(A_j b_k e^{i k R_j} + h.c.)$</span>.</p><p>The interactions between the system and the chain-mapped bath are long range, i.e. each site interacts with all the chain modes. The spectral density is assumed to be Ohmic <span>$J(ω) = 2αωc(ω/ωc)^s$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>R</code>: List of system&#39;s components positions</li><li><code>Nm</code>: Number of chain modes. The actual number of mode will be doubled to account for the left and right moving excitations.</li><li><code>d</code>: Local Hilbert space dimension of the bath modes</li><li><code>chainparams</code>: chain parameters, of the form <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</li><li><code>fnamecc</code>: Path to a file containing pre-computed long-range coupling coefficient. If not provided, the coupling coefficients will be computed and stored.</li><li><code>s</code>: Ohmicity</li><li><code>α</code>: Kondo parameter</li><li><code>ωc</code>: Bath cut-off frequency</li><li><code>c_phonon</code>: Speed of sound in the bath</li><li><code>β</code>: Inverse temperature </li><li><code>issoft</code>: Is the cut-off of the Ohmic SD soft or hard?</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}" href="#MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}"><code>MPSDynamics.hbathchain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hbathchain(N::Int, d::Int, chainparams, longrangecc...; tree=false, reverse=false, coupletox=false)</code></pre><p>Generate MPO representing a tight-binding chain of <code>N</code> oscillators with <code>d</code> Fock states each. Chain parameters are supplied in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>. The output does not itself represent a complete MPO but will possess an end which is <em>open</em> and should be attached to another tensor site, usually representing the <em>system</em>.</p><p><strong>Arguments</strong></p><ul><li><code>reverse</code>: If <code>reverse=true</code> create a chain were the last (i.e. Nth) site is the site which couples to the system</li><li><code>coupletox</code>: Used to choose the form of the system coupling. <code>coupletox=true</code> gives a non-number conserving coupling of the form <span>$H_{\text{I}}= A_{\text{S}}(b_{0}^\dagger + b_0)$</span> where <span>$A_{\text{S}}$</span> is a system operator, while <code>coupletox=false</code> gives the number-converving coupling <span>$H_{\text{I}}=(A_{\text{S}} b_{0}^\dagger + A_{\text{S}}^\dagger b_0)$</span></li><li><code>tree</code>: If <code>true</code> the resulting chain will be of type <code>TreeNetwork</code>; useful for construcing tree-MPOs </li></ul><p><strong>Example</strong></p><p>One can constuct a system site tensor to couple to a chain by using the function <code>up</code> to populate the tensor. For example, to construct a system site with Hamiltonian <code>Hs</code> and coupling operator <code>As</code>, the system tensor <code>M</code> is constructed as follows for a non-number conserving interaction:</p><pre><code class="language-julia hljs">u = one(Hs) # system identity
M = zeros(1,3,2,2)
M[1, :, :, :] = up(Hs, As, u)</code></pre><p>The full MPO can then be constructed with:</p><pre><code class="language-julia hljs">Hmpo = [M, hbathchain(N, d, chainparams, coupletox=true)...]</code></pre><p>Similarly for a number conserving interaction the site tensor would look like:</p><pre><code class="language-julia hljs">u = one(Hs) # system identity
M = zeros(1,4,2,2)
M[1, :, :, :] = up(Hs, As, As&#39;, u)</code></pre><p>And the full MPO would be</p><pre><code class="language-julia hljs">Hmpo = [M, hbathchain(N, d, chainparams; coupletox=false)...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.heisenbergmpo" href="#MPSDynamics.heisenbergmpo"><code>MPSDynamics.heisenbergmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">heisenbergmpo(N::Int, J=1.0) = xyzmpo(N; Jx=J)</code></pre><p>Generate MPO for the <code>N</code>-spin Heisenberg XXX model, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J σ_x^{n} σ_x^{n+1} - J σ_y^{n} σ_y^{n+1} - J σ_z^{n} σ_z^{n+1}$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.ibmmpo-NTuple{4, Any}" href="#MPSDynamics.ibmmpo-NTuple{4, Any}"><code>MPSDynamics.ibmmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ibmmpo(ω0, d, N, chainparams; tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to a chain of harmonic oscillators with the interacting boson model (IBM), defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z +  c_0σ_z(b_0^\dagger+b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span>.</p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + σ_z\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.interleaved_tightbinding_mpo-NTuple{4, Any}" href="#MPSDynamics.interleaved_tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.interleaved_tightbinding_mpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interleaved_tightbinding_mpo(N, ϵd, chainparams1, chainparams2)</code></pre><p>Generate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well) of energy ϵd. The impurity is coupled to two leads, each described by a set of chain parameters.  The interactions are next-nearest-neighbour, with the first site corresponding to the impurity, and the two chains organised in an interleaved fashion.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: number of sites in the chain</li><li><code>ϵd::Real</code>: energy of the impurity site at the first site, as Ed - μ, where μ is the chemical potential</li><li>chainparams1::Array{Real,1}: chain parameters for the first lead</li><li>chainparams2::Array{Real,1}: chain parameters for the second lead</li></ul><p>The chain parameters are given in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.isingmpo-Tuple{Int64}" href="#MPSDynamics.isingmpo-Tuple{Int64}"><code>MPSDynamics.isingmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isingmpo(N; J=1.0, h=1.0)</code></pre><p>Generate MPO for the <code>N</code>-spin 1D Ising model with external field <span>$\vec{h} = (0,0,h)$</span>, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J_x σ_x^{n} σ_x^{n+1} + \sum_{n=1}^{N}(- h_z σ_z^{n})$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.longrange_isingmpo" href="#MPSDynamics.longrange_isingmpo"><code>MPSDynamics.longrange_isingmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">longrange_isingmpo(N::Int, α::Float64=0.; J=1.0, h=1.0) = longrange_xyzmpo(N, α; Jx=J, Jy=0., Jz=0., hz=h, hx=0.)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.longrange_xyzmpo" href="#MPSDynamics.longrange_xyzmpo"><code>MPSDynamics.longrange_xyzmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">longrange_xyzmpo(N::Int, α::Float64=0.; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)</code></pre><p>Gennerate MPO for the <code>N</code>-spin long-range XYZ model with external field <span>$\vec{h}=(h_x, 0, h_z)$</span>, , defined by the Hamiltonian</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.multisitempo" href="#MPSDynamics.multisitempo"><code>MPSDynamics.multisitempo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multisitempo(N::Int, E=[]::Vector, J=[]::Vector, As=[]::Vector)</code></pre><p>Generate a MPO for a N-site multi-component system to be coupled with a correlated environment.</p><p><strong>Arguments:</strong></p><ul><li><code>N</code>: number of sites</li><li><code>E</code>: list of on-site energies</li><li><code>J</code>: list of sites tunnelling energies</li><li><code>As</code>: list of system operators coupling to the environment</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.nearestneighbourmpo" href="#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearestneighbourmpo(tree_::Tree, h0, A, Ad = A&#39;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.nearestneighbourmpo" href="#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nearestneighbourmpo(N::Int, h0, A, Ad = A&#39;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.protontransfermpo-NTuple{11, Any}" href="#MPSDynamics.protontransfermpo-NTuple{11, Any}"><code>MPSDynamics.protontransfermpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">protontransfermpo(ω0e,ω0k,x0e,x0k, Δ, dRC, d, N, chainparams, RCparams, λreorg)</code></pre><p>Generate a MPO for a system described in space with a reaction coordinate (RC) tensor. The Hamiltonian of the two-level system and of the reaction coordinate tensor reads </p><p><span>$H_S + H_{RC} + H_{int}^{S-RC} = \omega^0_{e} |e\rangle \langle e| + \omega^0_{k} |k\rangle \langle k| + \Delta (|e\rangle \langle k| + |k\rangle \langle e|) + \omega_{RC} (d^{\dagger}d + \frac{1}{2}) + g_{e} |e\rangle \langle e|( d + d^{\dagger})+ g_{k} |k \rangle \langle k|( d + d^{\dagger})$</span> The RC tensor is coupled to a bosonic bath, taking into account the induced reorganization energy <span>$H_B + H_{int}^{RC-B} = \int_{-∞}^{+∞} dk ω_k b_k^\dagger b_k - (d + d^{\dagger})\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \lambda_{reorg}(d + d^{\dagger})^2$</span> with <span>$\lambda_{reorg} = \int \frac{J(\omega)}{\omega}d\omega.$</span></p><p><strong>Arguments</strong></p><ul><li><code>ω0e</code>: enol energy at reaction coordinate value x=0 </li><li><code>ω0k</code>: keto energy at reaction coordinate value x=0</li><li><code>x0e</code>: enol equilibrium displacement</li><li><code>x0k</code>: keto equilibrium displacement </li><li><code>Δ</code>: direct coupling between enol and keto</li><li><code>dRC</code>: fock space of the RC tensor </li><li><code>d</code>: number of Fock states of the chain modes</li><li><code>N</code>: length of the bosonic chain</li><li><code>chainparams</code>: chain parameters, of the form <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature. </li><li><code>RCparams</code>: RC tensor parameter, of the form <code>RCparams</code>=<span>$[ω_RC,-g/x]$</span> </li><li><code>λreorg</code>: reorganization energy</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.puredephasingmpo-NTuple{4, Any}" href="#MPSDynamics.puredephasingmpo-NTuple{4, Any}"><code>MPSDynamics.puredephasingmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">puredephasingmpo(ΔE, dchain, Nchain, chainparams; tree=false)</code></pre><p>Generate MPO for a pure dephasing model, defined by the Hamiltonian <span>$H = \frac{ΔE}{2} σ_z +  \frac{σ_z}{2} c_0 (b_0^\dagger + b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N-1} ϵ_i b_i^\dagger b_i$</span></p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p><strong>Arguments</strong></p><ul><li><code>ΔE::Real</code>: energy splitting of the spin</li><li><code>dchain::Int</code>: physical dimension of the chain sites truncated Hilbert spaces</li><li><code>Nchain::Int</code>: number of sites in the chain</li><li><code>chainparams::Array{Real,1}</code>: chain parameters for the bath chain. The chain parameters are given in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>.</li><li><code>tree::Bool</code>: if true, return a <code>TreeNetwork</code> object, otherwise return a vector of MPO tensors</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.readchaincoeffs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readchaincoeffs(fdir, params...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.spinbosonmpo-NTuple{5, Any}" href="#MPSDynamics.spinbosonmpo-NTuple{5, Any}"><code>MPSDynamics.spinbosonmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinbosonmpo(ω0, Δ, d, N, chainparams; rwa=false, tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to a chain of harmonic oscillators, defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + c_0σ_x(b_0^\dagger+b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span>.</p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + Δσ_x + σ_x\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</p><p>The rotating wave approximation can be made by setting <code>rwa=true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.spinchainmpo-Tuple{Int64}" href="#MPSDynamics.spinchainmpo-Tuple{Int64}"><code>MPSDynamics.spinchainmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinchainmpo(N::Int; J=1.0, hz=1.0, hx=0.0, i=div(N,2))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.tightbinding_mpo-NTuple{4, Any}" href="#MPSDynamics.tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.tightbinding_mpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tightbinding_mpo(N, ϵd, chainparams1, chainparams2)</code></pre><p>Generate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well)  of energy ϵd at the center. The impurity is coupled to two leads, each described by a set of chain parameters. The interactions are nearest-neighbour, with the first N/2-1 sites corresponding to the first lead, the Nth site corresponding to the impurity, and the rest of the sites corresponding to the second lead.</p><p><strong>Arguments</strong></p><ul><li><code>N::Int</code>: number of sites in the chain</li><li><code>ϵd::Real</code>: energy of the impurity site at the center, as Ed - μ, where μ is the chemical potential</li><li><code>chainparams1::Array{Real,1}</code>: chain parameters for the first lead</li><li><code>chainparams2::Array{Real,1}</code>: chain parameters for the second lead</li></ul><p>The chain parameters are given in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}" href="#MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}"><code>MPSDynamics.tightbindingmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tightbindingmpo(N::Int, d::Int; J=1.0, e=1.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}" href="#MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}"><code>MPSDynamics.tunnelingmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tunnelingmpo(ϵ, delta, α, s, β, d::Int, nummodes::Int; tree=false, ωc=1)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.twobathspinmpo" href="#MPSDynamics.twobathspinmpo"><code>MPSDynamics.twobathspinmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">twobathspinmpo(ω0, Δ, Nl, Nr, dl, dr, chainparamsl=[fill(1.0,N),fill(1.0,N-1), 1.0], chainparamsr=chainparamsl; tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to two chains of harmonic oscillators, defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + c_0^rσ_x(b_0^\dagger+b_0) + \sum_{i=0}^{N_r-1} t_i^r (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N_r} ϵ_i^rb_i^\dagger b_i + c_0^lσ_x(d_0^\dagger+d_0) + \sum_{i=0}^{N_l-1} t_i^l (d_{i+1}^\dagger d_i +h.c.) + \sum_{i=0}^{N_l} ϵ_i^l d_i^\dagger d_i$</span>.</p><p>The spin is on site <span>$N_l + 1$</span> of the MPS, surrounded by the left chain modes and the right chain modes.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + Δσ_x + σ_x\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ωi + σ_x\int_0^∞ dω\sqrt{J^l(ω)}(d_ω^\dagger+d_ω) + \int_0^∞ dω ωd_ω^\dagger d_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature. The two chains can have a different spectral density.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.xxzmpo" href="#MPSDynamics.xxzmpo"><code>MPSDynamics.xxzmpo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xxzmpo(N::Int, Δ = 1.0, J=1.0) = xyzmpo(N; Jx=J, Jy=J, Jz=J*Δ)</code></pre><p>Generate MPO for the <code>N</code>-spin XXZ model, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J σ_x^{n} σ_x^{n+1} - J σ_y^{n} σ_y^{n+1} - \Delta J σ_z^{n} σ_z^{n+1}$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.xyzmpo-Tuple{Int64}" href="#MPSDynamics.xyzmpo-Tuple{Int64}"><code>MPSDynamics.xyzmpo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xyzmpo(N::Int; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)</code></pre><p>Generate MPO for the <code>N</code>-spin XYZ model with external field <span>$\vec{h}=(h_x, 0, h_z)$</span>, , defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J_x σ_x^{n} σ_x^{n+1} - J_y σ_y^{n} σ_y^{n+1} - J_z σ_z^{n} σ_z^{n+1} + \sum_{n=1}^{N}(- h_x σ_x^{n} - h_z σ_z^{n})$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div></section></article><h2 id="Chain-Mapping"><a class="docs-heading-anchor" href="#Chain-Mapping">Chain-Mapping</a><a id="Chain-Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-Mapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chaincoeffs_fermionic-Tuple{Any, Any, Any}" href="#MPSDynamics.chaincoeffs_fermionic-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_fermionic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chaincoeffs_fermionic(nummodes, β, chain; ϵ=x, ωc=1, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=true)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for a fermionic bath at the inverse temperature β. It can also save the generated coefficients in ../ChainOhmT/fermionicT/</p><p><strong>Arguments</strong></p><ul><li>nummodes: Number of bath modes</li><li>β: inverse temperature</li><li>chain: 1 if the chain modes are empty, 2 if the chain modes are filled</li><li>ϵ: user-provided dispersion relation. Should be a function f(x) where x is the wavenumber</li><li>J: user-provided spectral density. Should be a function f(x) where x is the wavenumber</li><li>ωc: the maximum frequency allowed in the spectral density</li><li>mc: the number of component intervals</li><li>mp: the number of points in the discrete part of the measure (mp=0 if there is none)</li><li>iq: a parameter to be set equal to 1, if the user provides his or her own quadrature routine, and different from 1 otherwise</li><li>idelta: a parameter whose default value is 1, but is preferably set equal to 2, if iq=1 and the user provides Gauss-type quadrature routines</li><li>procedure: choice between the Stieltjes and the Lanczos procedure</li><li>AB: component intervals. The defaut intervals are [[-Inf -ωc];[-ωc 0];[0 ωc];[ωc Inf]].</li><li>Mmax: maximum number of integration points</li><li>save: if true the coefficients are saved</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chaincoeffs_finiteT" href="#MPSDynamics.chaincoeffs_finiteT"><code>MPSDynamics.chaincoeffs_finiteT</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chaincoeffs_finiteT(nummodes, β, ohmic=true; α, s, J, ωc=1, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=true)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for a harmonic bath at the inverse temperature β. It can also save the generated coefficients in ../ChainOhmT/ohmicT/</p><p>By default a Ohmic spectral density <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span> is considered. Users can provide their own spectral density.</p><p><strong>Arguments</strong></p><ul><li>nummodes: Number of bath modes</li><li>β: inverse temperature</li><li>ohmic: true if the spectral density is Ohmic, false if the user provides its own spectral density</li><li>α: Kondo parameter of the Ohmic spectral density </li><li>s: ohmicity</li><li>J: user-provided spectral density. Should be a function f(x,i) where x is the frequency and i ∈ {1,...,mc} labels the intervals on which the SD is defined</li><li>ωc: the maximum frequency of the Ohmic spectral density</li><li>mc: the number of component intervals</li><li>mp: the number of points in the discrete part of the measure (mp=0 if there is none)</li><li>iq: a parameter to be set equal to 1, if the user provides his or her own quadrature routine, and different from 1 otherwise</li><li>idelta: a parameter whose default value is 1, but is preferably set equal to 2, if iq=1 and the user provides Gauss-type quadrature routines</li><li>procedure: choice between the Stieltjes and the Lanczos procedure</li><li>AB: component intervals. The defaut intervals are [[-Inf -ωc];[-ωc 0];[0 ωc];[ωc Inf]].</li><li>Mmax: maximum number of integration points</li><li>save: if true the coefficients are saved</li><li>smooth: if true the spectral density is multiplied by a decreasing exponential instead of a Heaviside function.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.chaincoeffs_finiteT_discrete-Tuple{Any, Any, Any}" href="#MPSDynamics.chaincoeffs_finiteT_discrete-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_finiteT_discrete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">chaincoeffs_finiteT_discrete(β, ωdiscrete, Jωdiscrete; procedure=:Lanczos, Mmax=5000, save=true)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for a discrete harmonic bath at the inverse temperature β.</p><p><strong>Arguments</strong></p><ul><li>β: inverse temperature. For 0 Kelvin, put Inf as β</li><li>ωdiscrete: discrete frequency corresponding to the Jωdiscrete values</li><li>Jωdiscrete: amplitude of the spectral density at the corresponding ωdiscrete</li><li>procedure: choice between the Stieltjes and the Lanczos procedure</li><li>Mmax: maximum number of integration points</li><li>save: if true the coefficients are saved</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.gauss-Tuple{Any, Any}" href="#MPSDynamics.gauss-Tuple{Any, Any}"><code>MPSDynamics.gauss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss(N,ab)</code></pre><p>Gauss quadrature rule for <code>N</code> sites on an interval <code>ab</code>. Given a weight function w encoded by the <code>N</code>x2 array <code>ab</code> of the first <code>N</code> recurrence coefficients for the associated orthogonal polynomials, the first column of <code>ab</code> containing the <code>N</code> alpha-coefficients and the second column the <code>N</code> beta-coefficients, the call xw = gauss(N,ab) generates the nodes and weights xw of the <code>N</code>-point Gauss quadrature rule for the weight function w. The nodes, in increasing order, are stored in the first column, the n corresponding weights in the second column, of the <code>N</code>x2 array xw.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.lanczos-Tuple{Any, Any}" href="#MPSDynamics.lanczos-Tuple{Any, Any}"><code>MPSDynamics.lanczos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lanczos(N,xw)</code></pre><p>Given the discrete inner product whose nodes are contained in the first column, and whose weights are contained in the second column, of the <code>N</code>x2 array <code>xw</code>, the call ab=lanczos(N,xw) generates the first <code>N</code> recurrence coefficients ab of the corresponding discrete orthogonal polynomials. The <code>N</code> alpha-coefficients are stored in the first column, the <code>N</code> beta-coefficients in the second column, of the <code>N</code>x2 array ab.</p><p>The script is adapted from the routine RKPW in W.B. Gragg and W.J. Harrod, ``The numerically stable reconstruction of Jacobi matrices from spectral data&#39;&#39;, Numer. Math. 44 (1984), 317-335.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.fermionicspectraldensity_finiteT-NTuple{6, Any}" href="#MPSDynamics.fermionicspectraldensity_finiteT-NTuple{6, Any}"><code>MPSDynamics.fermionicspectraldensity_finiteT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermionicspectraldensity_finiteT(x, i, β, chain; ϵ=x)

Fermionic spectral density at finite temperature β. A function f(x,i) where x is the frequency 
and i ∈ {1,...,mc} labels the intervals on which the SD is defined.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.ohmicspectraldensity_finiteT-NTuple{6, Any}" href="#MPSDynamics.ohmicspectraldensity_finiteT-NTuple{6, Any}"><code>MPSDynamics.ohmicspectraldensity_finiteT</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ohmicspectraldensity_finiteT(x,i,α,s,ωc,β; smooth=false)

Ohmic spectral density at finite temperature β. A function f(x,i) where x is the frequency 
and i ∈ {1,...,mc} labels the intervals on which the SD is defined. If smooth is set to true, the SD is multiplied by a 
decreasing exponential instead of a Heaviside function.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.stieltjes-Tuple{Any, Any}" href="#MPSDynamics.stieltjes-Tuple{Any, Any}"><code>MPSDynamics.stieltjes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stieltjes(N,xw)</code></pre><p>Discretized Stieltjes procedure. Given the discrete inner product whose nodes are contained in the first column, and whose weights are contained in the second column, of the <code>N</code>x2 array <code>xw</code>, the call ab=stieltjes(N,xw) generates the first <code>N</code> recurrence coefficients ab of the corresponding discrete orthogonal polynomials. The <code>N</code> alpha- coefficients are stored in the first column, the <code>N</code> beta-coefficients in the second column, of the <code>N</code>x2 array ab.</p></div></section></article><h2 id="Dynamics-propagation-function"><a class="docs-heading-anchor" href="#Dynamics-propagation-function">Dynamics propagation function</a><a id="Dynamics-propagation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamics-propagation-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.runsim-NTuple{4, Any}" href="#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">runsim(dt, tmax, A, H; 
	method=:TDVP1, 
	machine=LocalMachine(), 
	params=[], 
	obs=[], 
	convobs=[],
            convparams=error(&quot;Must specify convergence parameters&quot;),
            save=false,
            plot=save,
            savedir=string(homedir(),&quot;/MPSDynamics/&quot;),
            unid=randstring(5),
            name=nothing,
	kwargs...
	)</code></pre><p>Propagate the MPS <code>A</code> with the MPO <code>H</code> up to time <code>tmax</code> in time steps of <code>dt</code>. The final MPS is returned to <code>A</code> and the measurement data is returned to <code>dat</code> </p><p><strong>Arguments</strong></p><ul><li><code>method</code>: Several methods are implemented in MPSDynamics. <code>:TDVP1</code> refers to 1-site TDVP on tree and chain MPS, <code>:TDVP2</code> refers to 2-site TDVP on chain MPS, <code>:DTDVP</code> refers to a variant of 1-site TDVP with dynamics bond-dimensions on chain MPS</li><li><code>machine</code>: <code>LocalMachine()</code> points local ressources, <code>RemoteMachine()</code> points distant ressources</li><li><code>params</code>: list of parameters written in the log.txt file to describe the dynamics. Can be listed with @LogParams(). </li><li><code>obs</code>: list of observables that will be measured at every time step for the most accurate convergence parameter supplied to <code>convparams</code> </li><li><code>convobs</code>: list of observables that will be measure at every time step for every convergence parameter supplied to <code>convparams</code> </li><li><code>convparams</code>: list of convergence parameter with which the propagation will be calculated for every parameter. At each parameter, <code>convobs</code> are measured while <code>obs</code> are measured only for the most accurate dynamics</li><li><code>save</code>: Used to choose whether the data will also be saved to a file  </li><li><code>plot</code>: Used to choose whether plots for 1D observables will be automatically generated and saved along with the data</li><li><code>savedir</code>: Used to specify the path where resulting files are stored</li><li><code>unid</code>: Used to specify the name of the directory containing the resulting files</li><li><code>name</code>: Used to describe the calculation. This name will appear in the log.txt file</li></ul></div></section></article><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.ProgressBar-Tuple{Int64}" href="#MPSDynamics.ProgressBar-Tuple{Int64}"><code>MPSDynamics.ProgressBar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProgressBar(numsteps::Int; ETA=false, last=10)</code></pre><p>An iterable returning values from 1 to <code>numsteps</code>. Displays a progress bar for the for loop where it has been called. If ETA is true then displays an estimation of the remaining time calculated based on the time spent computing the last <code>last</code> values. The progress bar can be activated or deactivated by setting the <code>progressbar</code> keyword argument in <code>runsim</code> to true or false.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.mergetmp-Tuple{Any}" href="#MPSDynamics.mergetmp-Tuple{Any}"><code>MPSDynamics.mergetmp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mergetmp(tmpdir; fields=[], overwrite=true)</code></pre><p>Merges the temporary files created by the <code>ontheflysave</code> function at the directory <code>tmpdir</code> and returns a dictionnary containing the resulting data. By default all fields are present but one can select the fields of interest with a list of names in <code>fields</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.onthefly-Tuple{}" href="#MPSDynamics.onthefly-Tuple{}"><code>MPSDynamics.onthefly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">onthefly(;plot_obs=nothing::Union{&lt;:Observable, Nothing}, save_obs=Vector{Observable}(undef, 0)::Union{&lt;:Observable, Vector{&lt;:Observable}}, savedir=&quot;auto&quot;, step=10::Int, func=identity&lt;:Function, compare=nothing::Union{Tuple{Vector{Float64}, Vector{Float64}}, Nothing}, clear=identity&lt;:Function)</code></pre><p>Helper function returning a dictionnary containing the necessary arguments for on the fly plotting or saving in the <code>runsim</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>plot_obs</code> : Observable to plot</li><li><code>save_obs</code> : List of Observable(s) to save</li><li><code>savedir</code> : Used to specify the path where temporary files are stored, default is <code>&quot;auto&quot;</code> which saves in a &quot;tmp&quot; folder in the run folder (generally located at &quot;~/MPSDynamics/&lt;unid&gt;/tmp/&quot;). </li><li><code>step</code> : Number of time steps every which the function plots or saves the data</li><li><code>func</code> : Function to apply to the result of measurement of plot_obs (for example <code>real</code> or <code>abs</code> to make a complex result possible to plot)</li><li><code>compare</code> : Tuple <code>(times, data)</code> of previous results to compare against the plot_obs results,</li><li><code>clear</code> : Function used to clear the output before each attempt to plot, helpful for working in Jupyter notebooks where clear=IJulia.clear_output allows to reduce the size of the cell output</li></ul><p><strong>Examples</strong></p><p>For example in the <a href="../examples/sbm/#The-Spin-Boson-Model">Spin-Boson model example</a>, adding the following argument to the <code>runsim</code> function allows to save the &quot;sz&quot; observable <code>ob1</code> in the directory &quot;~/MPSDynamics/&lt;unid&gt;/tmp/&quot; and plot its real part during the simulation:</p><pre><code class="language-julia hljs">runsim(..., onthefly=onthefly(plot_obs=ob1, save_obs=[ob1], savedir=&quot;auto&quot;, step=10, func=real))</code></pre><p>To merge the temporary files in one usable file, one can then use <a href="#MPSDynamics.mergetmp-Tuple{Any}"><code>MPSDynamics.mergetmp</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.ontheflyplot-NTuple{4, Any}" href="#MPSDynamics.ontheflyplot-NTuple{4, Any}"><code>MPSDynamics.ontheflyplot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ontheflyplot(onthefly, tstep, times, data)</code></pre><p>Plots data according to the arguments of the <code>onthefly</code> dictionnary.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MPSDynamics.ontheflysave-NTuple{4, Any}" href="#MPSDynamics.ontheflysave-NTuple{4, Any}"><code>MPSDynamics.ontheflysave</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ontheflysave(onthefly, tstep, times, data)</code></pre><p>Saves data according to the arguments of the <code>onthefly</code> dictionnary.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theoretical Background</a><a class="docs-footer-nextpage" href="../dev/">Developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 16 May 2025 14:09">Friday 16 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
