<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Anderson Impurity Model · MPSDynamics.jl</title><meta name="title" content="The Anderson Impurity Model · MPSDynamics.jl"/><meta property="og:title" content="The Anderson Impurity Model · MPSDynamics.jl"/><meta property="twitter:title" content="The Anderson Impurity Model · MPSDynamics.jl"/><meta name="description" content="Documentation for MPSDynamics.jl."/><meta property="og:description" content="Documentation for MPSDynamics.jl."/><meta property="twitter:description" content="Documentation for MPSDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../user-guide/">User Guide</a></li><li><a class="tocitem" href="../../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../puredephasing/">Pure-Dephasing</a></li><li><a class="tocitem" href="../timedep/">Time-dependent Hamiltonian</a></li><li class="is-active"><a class="tocitem" href>The Anderson Impurity Model</a><ul class="internal"><li><a class="tocitem" href="#Basics-of-the-fermionic-chain-mapping"><span>Basics of the fermionic chain mapping</span></a></li><li><a class="tocitem" href="#Code-implementation"><span>Code implementation</span></a></li><li><a class="tocitem" href="#Bibliography"><span>Bibliography</span></a></li></ul></li><li><a class="tocitem" href="../bath-observables/">Inspecting the bath by undoing the chain mapping</a></li><li><a class="tocitem" href="../protontransfer/">Proton Transfer Model</a></li><li><a class="tocitem" href="../tailored_sd/">Tailoring the Spectral Density</a></li></ul></li><li><a class="tocitem" href="../../convergence/">Convergence checks</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><a class="tocitem" href="../../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>The Anderson Impurity Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Anderson Impurity Model</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Anderson-Impurity-Model"><a class="docs-heading-anchor" href="#The-Anderson-Impurity-Model">The Anderson Impurity Model</a><a id="The-Anderson-Impurity-Model-1"></a><a class="docs-heading-anchor-permalink" href="#The-Anderson-Impurity-Model" title="Permalink"></a></h1><p>Here we give some context on the examples provided in <code>MPSDynamics/examples/anderson_model_double.jl</code> and <code>MPSDynamics/examples/anderson_model_interleaved.jl</code>. In these two examples, we use the fermionic chain mapping proposed in <sup class="footnote-reference"><a id="citeref-khon_efficient_2021" href="#footnote-khon_efficient_2021">[khon_efficient_2021]</a></sup> to show how to perform tensor network simulations of the <a href="https://en.wikipedia.org/wiki/Anderson_impurity_model">Single Impurity Anderson Model</a> (SIAM) with the <code>MPSDynamics.jl</code> library. </p><h2 id="Basics-of-the-fermionic-chain-mapping"><a class="docs-heading-anchor" href="#Basics-of-the-fermionic-chain-mapping">Basics of the fermionic chain mapping</a><a id="Basics-of-the-fermionic-chain-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Basics-of-the-fermionic-chain-mapping" title="Permalink"></a></h2><p>Before giving the code implementation, a short recap on the problem statement and on the fermionic mapping used to solved it. The SIAM Hamiltonian is defined as:</p><p class="math-container">\[    \hat H^\text{SIAM}  = \hat H_\text{loc} + \hat H_\text{hyb} + \hat H_\text{cond} = \overbrace{\epsilon_d \hat d^\dagger \hat d}^{\hat H_\text{loc}} + \underbrace{\sum_{k} V_k \Big( \hat d^\dagger \hat c_k + \hat c_k^\dagger \hat d \Big)}_{\hat H_\text{hyb}} + \underbrace{\sum_k \epsilon_k \hat c_k^\dagger \hat c_k}_{\hat H_\text{cond}}.\]</p><p>This Hamiltonian represents a located impurity (<span>$\hat H_\text{loc}$</span>), conduction electrons (<span>$\hat H_\text{cond}$</span>) and a hybridization term between the impurity and the conduction electrons (<span>$\hat H_\text{hyb}$</span>). All of the operators obey to the usual fermionic anti-commutation relations: <span>$\{\hat c_i, \hat c_j^\dagger \} = \delta_{ij}$</span>, <span>$\{\hat c_i, \hat c_j \} =\{\hat c_i^\dagger, \hat c_j^\dagger \} =0$</span> <span>$\forall i,j$</span>. The chain mapping is based on a thermofield-like transformation  <sup class="footnote-reference"><a id="citeref-devega_thermo_2015" href="#footnote-devega_thermo_2015">[devega_thermo_2015]</a></sup>, performed with fermions: ancillary fermionic operators <span>$\hat c_{2k}$</span> are defined, one for each of the original fermionic modes <span>$\hat c_{1k}$</span>. A Bogoliubov transformation is then applied, so that two new fermionic modes <span>$\hat f_{1k}$</span> and <span>$\hat f_{2k}$</span> are defined as a linear combination of <span>$\hat c_{1k}$</span> and <span>$\hat c_{2k}$</span>. Two chains are defined: the chain labelled <span>$1$</span> for the empty modes:</p><p class="math-container">\[\hat f_{1k}=e^{-iG}  \hat c_k e^{iG}= \cosh(\theta_k) \hat c_{1k} -\sinh(\theta_k)  \hat c_{2k}^\dagger \\
\hat f_{2k}=e^{-iG} \hat c_k e^{iG}= \cosh(\theta_k)  \hat c_{1k} +\sinh(\theta_k)  \hat c_{2k}^\dagger.\]</p><p>We remark that this is the same Bogoliubov transformation used in the thermofield<sup class="footnote-reference"><a id="citeref-devega_thermo_2015" href="#footnote-devega_thermo_2015">[devega_thermo_2015]</a></sup> for the bosonic case: the only thing that changes is a plus sign, that takes into account the fermionic anti-commutation relations. With these new fermionic operators we obtain the thermofield-transformed Hamiltonian, where the system interacts with two environments at zero temperature, allowing for pure state simulations (and thus the employement of MPS).</p><p>The thermofield-transformed Hamiltonian is then mapped on two chains, defined and constructed using the TEDOPA chain mapping: the chain labelled <span>$1$</span> is for the empty modes, the chain labelled <span>$2$</span> for the filled modes. The following relations are used to define the functions equivalent to the spectral density of the bosonic case, one for each chain:</p><p class="math-container">\[\begin{aligned}
   &amp;V_{1k} = V_{k} \sin \theta_k = \sqrt{\frac{1}{e^{\beta \epsilon_k}+1}} \\
   &amp;V_{2k} = V_{k} \cos \theta_k = \sqrt{\frac{1}{e^{-\beta \epsilon_k}+1}}, 
\end{aligned}\]</p><p>where we choose the spectral function that characterizes the fermionic bath to be: <span>$V_k= \sqrt{1-k^2}$</span>, and we define the dispersion relation as: <span>$e_k = k$</span>, that is, a linear dispersion relation with propagation speed equal to <span>$1$</span>. This latter choice corresponds to a model of metals (gapless energy spectrum). We select a filled state as the initial state of the defect. Using the mapping proposed, the chain Hamiltonian becomes:</p><p class="math-container">\[    \begin{aligned}
    \hat H^\text{chain}  = \hat H_\text{loc} &amp;+ \sum_{i = \{1,2\}}\bigg[ J_{i,0} \Big(\hat d^\dagger \hat a_{i,0} + \hat d \hat a_{i,0}^\dagger \Big) + \\ &amp;+ \sum_{n=1}^\infty  \Big( J_{i,n} \hat a_{i,n}^\dagger \hat a_{i,n-1} +  J_{i,n} \hat  a_{i,n-1}^\dagger \hat a_{i,n} \Big) + \sum_{n=0}^\infty E_{i,n} \hat  a_{i,n}^\dagger \hat a_{i,n} \bigg],
    \end{aligned}\]</p><p>where the <span>$J_{i,n}$</span> coefficients are the couplings between the chain sites and the <span>$E_{i,n}$</span> coefficients are the energies associated to each chain site. Clearly, the interactions are between nearest neighbors. This, combined with the fact that the fermions in our model are spinless, enables a straightforward mapping into fermionic operators of the bosonic creation and annihilation operators, that on their part obey to the bosonic commutation relations: <span>$[\hat b_i, \hat b_j^\dagger] = \delta_{ij}$</span>, <span>$[\hat b_i, \hat b_j] =[\hat b_i^\dagger, \hat b_j^\dagger] =0$</span> <span>$\forall i,j$</span>. The mapping derived from Jordan-Wigner transformations for spinless fermions is:</p><p class="math-container">\[    \hat a_{i}^\dagger \hat a_{i+1} + \hat a_{i+1}^\dagger \hat a_{i} = \hat b_{i}^\dagger \hat b_{i+1} + \hat b_{i+1}^\dagger \hat b_{i}.  \]</p><h3 id="Double-chain-MPO"><a class="docs-heading-anchor" href="#Double-chain-MPO">Double chain MPO</a><a id="Double-chain-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#Double-chain-MPO" title="Permalink"></a></h3><p><img src="../doublechain.png" alt="image"/></p><p>We can represent the Hamiltonian <span>$\hat H^\text{chain}$</span> as a MPOs bond dimension is: <span>$\chi = 4$</span>. The MPO has the structure of a double chain, with an impurty site at the center, and therefore can be seen as the product of the following matrices:</p><p class="math-container">\[    H = W_{1N} \cdot...\cdot W_{1 0} \cdot W_d \cdot W_{20} \cdot ... \cdot W_{2 N},  \]</p><p>where the matrices are defined as:</p><p class="math-container">\[\begin{aligned}
&amp; W_{1N} = 
\begin{bmatrix}
\hat{\mathbb I} &amp; J_{2,N} \hat b_{2,N}^\dagger &amp; J_{2,N} \hat b_{2,N} &amp; E_{2,N} \hat b_{2,N}^\dagger \hat b_{2,N} 
\end{bmatrix}, \quad   W_{1 0} = 
\begin{bmatrix}
 \hat{ \mathbb I} &amp; J_{2,0} \hat b_{2,0}^\dagger &amp; J_{2,0} \hat b_{2,0} &amp; E_{2,0} \hat b_{2,0}^\dagger \hat b_{2,0}\\
0 &amp;0 &amp; 0 &amp; \hat b_{2,0} \\
0 &amp;0 &amp; 0 &amp; \hat b_{2,0}^\dagger \\
0 &amp;0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}, \\
&amp; W_d = 
\begin{bmatrix}
 \hat{ \mathbb I} &amp; \hat d^\dagger &amp; \hat d &amp; \epsilon_d \hat d^\dagger \hat d\\
0 &amp;0 &amp; 0 &amp; \hat d \\
0 &amp;0 &amp; 0 &amp; \hat d^\dagger \\
0 &amp;0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}\\ ,
&amp; W_{2 0} =
\begin{bmatrix}
 \hat{ \mathbb I} &amp; \hat b_{1,0}^\dagger &amp; \hat b_{1,0} &amp; E_{1,0} \hat b_{1,0}^\dagger \hat b_{1,0}\\
0 &amp;0 &amp; 0 &amp; \hat J_{1,0}b_{1,0} \\
0 &amp;0 &amp; 0 &amp; \hat J_{1,0}b_{1,0}^\dagger \\
0 &amp;0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}
, \quad W_{2 N} =
\begin{bmatrix}
 E_{2,N} \hat b_{2,N}^\dagger \hat b_{2,N} \\ J_{2,N} \hat b_{2,N} \\ J_{2,N} \hat b_{2,N}^\dagger \\ \hat{\mathbb I}
\end{bmatrix}.
\end{aligned}\]</p><h3 id="Interleaved-chain-MPO"><a class="docs-heading-anchor" href="#Interleaved-chain-MPO">Interleaved chain MPO</a><a id="Interleaved-chain-MPO-1"></a><a class="docs-heading-anchor-permalink" href="#Interleaved-chain-MPO" title="Permalink"></a></h3><p><img src="../foldedchain.png" alt="image"/></p><p>The drawback of the double chain representation is that the particle-hole pairs are spatially separated in the MPS, creating correlations and therefore leading to a dramatic increase in the bond dimensions. This is why Kohn and Santoro propose an interleaved geometry, the advantages of which are thoroughly explained in <sup class="footnote-reference"><a id="citeref-khon_eff_2022" href="#footnote-khon_eff_2022">[khon_eff_2022]</a></sup>. Exploiting the interleaved representation, the interaction comes to be between next-nearest neighbors: a string operator appears in the Jordan-Wigner transformation from bosons to fermions:</p><p class="math-container">\[    \hat a_{i}^\dagger \hat a_{i+2} + \hat a_{i+2}^\dagger \hat a_{i} = \hat b_{i}^\dagger \hat F_{i+1} \hat b_{i+2} + \hat b_{i} \hat F_{i+1} \hat b_{i+2}^\dagger,\]</p><p>where the string operator <span>$\hat F_i$</span> is defined as: <span>$\hat F_i = (-1)^{\hat n_i} = \hat{\mathbb I} -2 \hat n_i = \hat{\mathbb I}-2 \hat b_i^\dagger \hat b_i$</span>.  It is possible to find the analytical form also for MPOs with long range interaction. In the case of next-nearest neighbors interactions between spinless fermions, in the interleaved geometry of the figure above, the MPO representation will require a bond dimension <span>$\chi=6$</span>. We explicitly write it as:</p><p class="math-container">\[    H = W_{d} \cdot W_{2 0} \cdot W_{1 0} \cdot...\cdot W_{2N} \cdot W_{1 N},  \]</p><p>where the matrices are defined as: </p><p class="math-container">\[\begin{aligned}
&amp; W_d = 
\begin{bmatrix}
 \hat{\mathbb I} &amp; \hat d &amp; \hat d^\dagger &amp; 0 &amp; 0 &amp; E_{d} \hat d^\dagger \hat d 
\end{bmatrix}, \quad W_{2 0} = 
\begin{bmatrix}
 \hat{ \mathbb I} &amp; \hat b_{2,0} &amp; \hat b_{2,0}^\dagger &amp; 0 &amp; 0 &amp; E_{2,0} \hat b_{2,0}^\dagger \hat b_{2,0}\\
0 &amp;0 &amp; 0 &amp; \hat{F}_{2,0} &amp; 0 &amp; J_{2,0} \hat b_{2,0}^\dagger \\
0 &amp;0 &amp; 0 &amp; 0 &amp; \hat{F}_{2,0} &amp; J_{2,0} \hat b_{2,0} \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp;  0\\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}, \\
&amp; W_{1 0} = 
\begin{bmatrix}
 \hat{ \mathbb I} &amp; \hat b_{1,0} &amp; \hat b_{1,0}^\dagger &amp; 0 &amp; 0 &amp; E_{1,0} \hat b_{1,0}^\dagger \hat b_{1,0}\\
0 &amp;0 &amp; 0 &amp; \hat{ F}_{1,0} &amp; 0 &amp; 0 \\
0 &amp;0 &amp; 0 &amp; 0 &amp; \hat{F}_{1,0} &amp; 0 \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; J_{1,0} \hat b_{1,0}^\dagger \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; J_{1,0} \hat b_{1,0} \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}, \\
&amp; W_{2,N} = 
\begin{bmatrix}
 \hat{ \mathbb I} &amp; \hat b_{2,N} &amp; \hat b_{2,N}^\dagger &amp; 0 &amp; 0 &amp; E_{2,N} \hat b_{2,N}^\dagger \hat b_{2,N}\\
0 &amp;0 &amp; 0 &amp; \hat{F}_{2,N} &amp; 0 &amp; 0 \\
0 &amp;0 &amp; 0 &amp; 0 &amp; \hat{F}_{2,N} &amp; 0 \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; J_{2,N} \hat b_{2,N}^\dagger \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; J_{2,N} \hat b_{2,N} \\
0 &amp;0 &amp; 0 &amp; 0 &amp; 0 &amp; \hat{\mathbb I}
\end{bmatrix}, 
\quad W_{1 N}
\begin{bmatrix}
 E_{1,N} \hat b_{1,N}^\dagger \hat b_{1,N} \\ 0 \\0 \\ J_{1,N} \hat b_{1,N}^\dagger \\ J_{1,N} \hat b_{1,N} \\ \hat{\mathbb I}
\end{bmatrix} .
\end{aligned}\]</p><h2 id="Code-implementation"><a class="docs-heading-anchor" href="#Code-implementation">Code implementation</a><a id="Code-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Code-implementation" title="Permalink"></a></h2><p>The fermionic mapping can be strightforwardly implemented with the methods of <code>MPSDynamics.jl</code>. We provide two examples: </p><ul><li><code>examples/anderson_model_double</code>, simulating the SIAM with the double-chain geometry</li><li><code>examples/anderson_model_interleaved</code>, simulating the SIAM with the interleaved-chain geometry</li></ul><p>They only differ on the way the Hamiltonian MPO is defined. We now briefly review the important bits of the code.</p><p>Both of the examples start with the definition of the physical parameters,</p><pre><code class="language-julia hljs">N = 40      # number of chain sites
β = 10.0     # inverse temperature
μ = 0.      # chemical potential
Ed = 0.3    # energy of the impurity
ϵd = Ed - μ # energy of the impurity minus the chemical potential</code></pre><p>The <a href="../../methods/#MPSDynamics.chaincoeffs_fermionic-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_fermionic</code></a> function is needed to compute the chain coefficients. It requires as inputs the number of modes of each chain <code>N</code>, the inverse temperature <code>β</code>, a label to specify if the chain modes are empty (label is <code>1.0</code>) or filled (label is <code>2.0</code>), and both the dispersion relation <span>$\epsilon_k$</span> and the fermionic spectral density funciton <span>$V_k$</span>.</p><pre><code class="language-julia hljs">function ϵ(x)
    return x
end

function V(x)
    return sqrt(1 - x^2) # semi-circular density of states
end

chainparams1 = chaincoeffs_fermionic(N, β, 1.0; ϵ, V, save=false) # empty
chainparams2 = chaincoeffs_fermionic(N, β, 2.0; ϵ, V, save=false) # filled</code></pre><p>We then specify the simulation parameters</p><pre><code class="language-julia hljs">dt = 0.25           # time step
T = 15.0            # simulation time
method = :DTDVP     # time-evolution method
Dmax = 150          # MPS max bond dimension
prec = 0.0001       # precision for the adaptive TDVP
</code></pre><p>and with this we are ready to construct the Hamiltonian MPO and specify the initial state, which will obviously differ depending on the chosen geometry.</p><h4 id="Double-chain-geometry"><a class="docs-heading-anchor" href="#Double-chain-geometry">Double chain geometry</a><a id="Double-chain-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Double-chain-geometry" title="Permalink"></a></h4><p>The Hamiltonian is defined using the <a href="../../methods/#MPSDynamics.tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.tightbinding_mpo</code></a> function, which takes as an input the number of modes of each chain <code>N</code>, the defect&#39;s energy <code>ϵd</code>, and the chain coefficients of the first <code>chainparams1</code> and second <code>chainparams2</code> chain. The MPS for the initial state is a factorized state made of: N filled states, a filled impurity, and N empty states. </p><pre><code class="language-julia hljs">H = tightbinding_mpo(N, ϵd, chainparams1, chainparams2)

ψ =  unitcol(2,2) # (0,1) filled impurity state
A = productstatemps(physdims(H), state=[fill(unitcol(2,2), N)..., ψ, fill(unitcol(1,2), N)...]) # MPS</code></pre><p>To avoid the <code>DTDVP</code> algorithm from getting stuck in a local minimum, it is better to embed the MPS in a manifold of bond dimension 2 (or more):</p><pre><code class="language-julia hljs">mpsembed!(A, 2) # to embed the MPS in a manifold of bond dimension 2</code></pre><p>We can now define the observables for the two chains and for the impurity</p><pre><code class="language-julia hljs">ob1 = OneSiteObservable(&quot;chain1_filled_occup&quot;, numb(2), (1,N))
ob2 = OneSiteObservable(&quot;chain2_empty_occup&quot;, numb(2), (N+2, 2N+1))
ob3 = OneSiteObservable(&quot;system_occup&quot;, numb(2), N+1)</code></pre><p>and run the simulation</p><pre><code class="language-julia hljs">A, dat = runsim(dt, T, A, H;
                name = &quot;Anderson impurity problem (folded chain)&quot;,
                method = method,
                obs = [ob1, ob2, ob3], 
                convobs = [ob1],
                params = @LogParams(N, ϵd, β),
                convparams = [prec],   
                Dlim = Dmax,          
                savebonddims = true,   # we want to save the bond dimension
                verbose = false,
                save = false,
                plot = true,
                );</code></pre><p>With very minimal post-processing of the data</p><pre><code class="language-julia hljs"># Reshaping the vector to a column matrix and horizontal concatenation
system_occup_col = reshape(dat[&quot;data/system_occup&quot;], :, 1)
occ = hcat(dat[&quot;data/chain1_filled_occup&quot;]&#39;, system_occup_col)
occ = vcat(occ&#39;, dat[&quot;data/chain2_empty_occup&quot;])</code></pre><p>we plot the results:</p><pre><code class="language-julia hljs"># Plot the system occupation    
p1 = plot(
    dat[&quot;data/times&quot;],
    dat[&quot;data/system_occup&quot;],
    xlabel = L&quot;$t$&quot;,
    ylabel = L&quot;$n_d$&quot;,
    title = &quot;System Occupation&quot;,
    size = (700, 500)
)

# Plot the occupation of the chain sites
p2 = heatmap(
    collect(1:2*N+1),
    dat[&quot;data/times&quot;],
    transpose(occ),  # Use the matrix form
    cmap = :coolwarm,
    aspect_ratio = :auto,
    xlabel = L&quot;$N_{i,j}$ chain sites&quot;,
    ylabel = L&quot;$t$&quot;,
    title = &quot;Chain Occupation&quot;,
    colorbar = true,
    size = (700, 500)
)

# Plot the bond dimensions
p3 = heatmap(
    collect(1:2*N+2),
    dat[&quot;data/times&quot;],
    transpose(dat[&quot;data/bonddims&quot;]),
    cmap = :magma,
    aspect_ratio = :auto,
    xlabel = L&quot;$N_{i,j}$ chain sites&quot;,
    ylabel = L&quot;$t$&quot;,
    title = &quot;Bond Dimensions&quot;,
    colorbar = true,
    size = (700, 500)
)

# Define indices for columns to be plotted
columns_to_plot = [1, 5, 10, 15, 20]

# Plot vertical slices for occupancy
p4 = plot(title = &quot;Chain occupation&quot;)
for col in columns_to_plot
    plot!(p4, occ[:, col], label = L&quot;$t =$&quot;*&quot;$col&quot;, xlabel = L&quot;$N_{i,j}$ chain sites&quot;, ylabel = &quot;chain occupation&quot;)
end

# Plot vertical slices for bond dimensions
p5 = plot(title = &quot;Bond Dimensions&quot;)
for col in columns_to_plot
    plot!(p5, dat[&quot;data/bonddims&quot;][:, col], label = L&quot;$t =$&quot;*&quot;$col&quot;, xlabel = L&quot;$N_{i,j}$ chain sites&quot;, ylabel = L&quot;$\chi$&quot;)
end

# Display the plots
plot(p2, p3, p4, p5, p1, layout = (3, 2), size = (1400, 1200))
</code></pre><p><img src="../double_output.svg" alt="Output of this program"/></p><h4 id="Interleaved-chain-geometry"><a class="docs-heading-anchor" href="#Interleaved-chain-geometry">Interleaved chain geometry</a><a id="Interleaved-chain-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Interleaved-chain-geometry" title="Permalink"></a></h4><p>The Hamiltonian is defined using the <a href="../../methods/#MPSDynamics.interleaved_tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.interleaved_tightbinding_mpo</code></a> function, which takes as an input the number of modes of each chain <code>N</code>, the defect&#39;s energy <code>ϵd</code>, and the chain coefficients of the first <code>chainparams1</code> and second <code>chainparams2</code> chain. The MPS for the initial state is a factorized state (bond dimension 1) made of: a filled impurity, and 2N alternate filled-empty states. </p><pre><code class="language-julia hljs">H = interleaved_tightbinding_mpo(N, ϵd, chainparams1, chainparams2)

ψ =  unitcol(2,2) # (0,1) filled impurity state
Tot = Any[]
push!(Tot, ψ)
for i in 1:(N)
    push!(Tot, unitcol(2,2))
    push!(Tot, unitcol(1,2))
end

A = productstatemps(physdims(H), state=Tot) # MPS</code></pre><p>To avoid the <code>DTDVP</code> algorithm from getting stuck in a local minimum, it is better to embed the MPS in a manifold of bond dimension 2 (or more):</p><pre><code class="language-julia hljs">mpsembed!(A, 2) # to embed the MPS in a manifold of bond dimension 2</code></pre><p>We can finally define the observables for the interleaved chain</p><pre><code class="language-julia hljs">ob1 = OneSiteObservable(&quot;system_occup&quot;, numb(2), 1)
ob2 = OneSiteObservable(&quot;folded_chain_occup&quot;, numb(2), (2,2N+1))</code></pre><p>and run the simulation</p><pre><code class="language-julia hljs">A, dat = runsim(dt, T, A, H;
                name = &quot;Anderson impurity problem (folded chain)&quot;,
                method = method,
                obs = [ob1, ob2], 
                convobs = [ob1],
                params = @LogParams(N, ϵd, β),
                convparams = [prec],   
                Dlim = Dmax,          
                savebonddims = true,   # we want to save the bond dimension
                verbose = false,
                save = false,
                plot = true,
                );</code></pre><p>To show the data in a clear way, we do a bit of post-processing of the data to <em>unfold</em> the chain, and move back to the double chain representation:</p><pre><code class="language-julia hljs">unfolded_occ = Vector{Vector{Float64}}()  # Assuming the elements are of type Float64
unfolded_bonds = Vector{Vector{Float64}}()  # Adjust the type based on actual data

# Populate unfolded_occ by iterating in the specific order mentioned
for i in 1:N  # Adjusted for 1-based indexing
    push!(unfolded_occ, dat[ &quot;data/folded_chain_occup&quot;][2N + 1 - 2i, :])
end

push!(unfolded_occ, dat[&quot;data/folded_chain_occup&quot;][1,:])

for i in 2:N
    push!(unfolded_occ, dat[&quot;data/folded_chain_occup&quot;][2i,:])
end

# Populate unfolded_bonds similarly
for i in 1:(N+1)  # Adjusted for 1-based indexing
    push!(unfolded_bonds, dat[&quot;data/bonddims&quot;][2N + 3 - 2i,:])  # Assuming bonddims is directly accessible
end

push!(unfolded_bonds, dat[&quot;data/bonddims&quot;][1,:])

for i in 2:(N+1)
    push!(unfolded_bonds, dat[&quot;data/bonddims&quot;][2i,:])
end

unfolded_bonds_matrix = hcat(unfolded_bonds...)&#39;
unfolded_occ_matrix = hcat(unfolded_occ...)&#39;</code></pre><p>We conclude by plotting the data</p><pre><code class="language-julia hljs"># Plot the system occupation    
p1 = plot(
    dat[&quot;data/times&quot;],
    dat[&quot;data/system_occup&quot;],
    xlabel = L&quot;$t$&quot;,
    ylabel = L&quot;$n_d$&quot;,
    title = &quot;System Occupation&quot;,
    size = (700, 500)
)

# Plot the occupation of the chain sites
p2 = heatmap(
    collect(1:2*N),
    dat[&quot;data/times&quot;],
    transpose(unfolded_occ_matrix),  # Use the matrix form
    cmap = :coolwarm,
    aspect_ratio = :auto,
    xlabel = L&quot;$N_{i,j}$ chain sites&quot;,
    ylabel = L&quot;$t$&quot;,
    title = &quot;Chain Occupation&quot;,
    colorbar = true,
    size = (700, 500)
)

# Plot the bond dimensions
p3 = heatmap(
    collect(1:2*N+2),
    dat[&quot;data/times&quot;],
    transpose(unfolded_bonds_matrix),
    cmap = :magma,
    aspect_ratio = :auto,
    xlabel = L&quot;$N_{i,j}$ chain sites&quot;,
    ylabel = L&quot;$t$&quot;,
    title = &quot;Bond Dimensions&quot;,
    colorbar = true,
    size = (700, 500)
)

# Define indices for columns to be plotted
columns_to_plot = [1, 5, 10, 15, 20]


# Plot vertical slices for occupancy
p4 = plot(title = &quot;Chain occupation&quot;)
for col in columns_to_plot
    plot!(p4, unfolded_occ_matrix[:, col], label = L&quot;$t =$&quot;*&quot;$col&quot;, xlabel = L&quot;$N_{i,j}$ chain sites&quot;, ylabel = &quot;chain occupation&quot;)
end

# Plot vertical slices for bond dimensions
p5 = plot(title = &quot;Bond Dimensions&quot;)
for col in columns_to_plot
    plot!(p5, unfolded_bonds_matrix[:, col], label = L&quot;$t =$&quot;*&quot;$col&quot;, xlabel = L&quot;$N_{i,j}$ chain sites&quot;, ylabel = L&quot;$\chi$&quot;)
end

# Display the plots
plot(p2, p3, p4, p5, p1, layout = (3, 2), size = (1400, 1200))</code></pre><p><img src="../interleaved_output.svg" alt="Output of this program"/></p><p>________________</p><h2 id="Bibliography"><a class="docs-heading-anchor" href="#Bibliography">Bibliography</a><a id="Bibliography-1"></a><a class="docs-heading-anchor-permalink" href="#Bibliography" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-khon_efficient_2021"><a class="tag is-link" href="#citeref-khon_efficient_2021">khon_efficient_2021</a><blockquote><p>Kohn, L.; Santoro, G. E. Efficient mapping for anderson impurity problems with matrix product states. Phys. Rev. B 2021, 104 (1), 014303. https://doi.org/10.1103/PhysRevB.104.014303.</p></blockquote></li><li class="footnote" id="footnote-devega_thermo_2015"><a class="tag is-link" href="#citeref-devega_thermo_2015">devega_thermo_2015</a><blockquote><p>de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.</p></blockquote></li><li class="footnote" id="footnote-khon_eff_2022"><a class="tag is-link" href="#citeref-khon_eff_2022">khon_eff_2022</a><blockquote><p>Kohn L.; Santoro G. E. J. Stat. Mech. (2022) 063102 DOI 10.1088/1742-5468/ac729b.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../timedep/">« Time-dependent Hamiltonian</a><a class="docs-footer-nextpage" href="../bath-observables/">Inspecting the bath by undoing the chain mapping »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 28 March 2025 18:58">Friday 28 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
