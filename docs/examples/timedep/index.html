<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time-dependent Hamiltonian · MPSDynamics.jl</title><meta name="title" content="Time-dependent Hamiltonian · MPSDynamics.jl"/><meta property="og:title" content="Time-dependent Hamiltonian · MPSDynamics.jl"/><meta property="twitter:title" content="Time-dependent Hamiltonian · MPSDynamics.jl"/><meta name="description" content="Documentation for MPSDynamics.jl."/><meta property="og:description" content="Documentation for MPSDynamics.jl."/><meta property="twitter:description" content="Documentation for MPSDynamics.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MPSDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../user-guide/">User Guide</a></li><li><a class="tocitem" href="../../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../puredephasing/">Pure-Dephasing</a></li><li class="is-active"><a class="tocitem" href>Time-dependent Hamiltonian</a><ul class="internal"><li><a class="tocitem" href="#Context"><span>Context</span></a></li><li><a class="tocitem" href="#The-code"><span>The code</span></a></li></ul></li><li><a class="tocitem" href="../anderson-model/">The Anderson Impurity Model</a></li><li><a class="tocitem" href="../bath-observables/">Inspecting the bath by undoing the chain mapping</a></li><li><a class="tocitem" href="../protontransfer/">Proton Transfer Model</a></li><li><a class="tocitem" href="../tailored_sd/">Tailoring the Spectral Density</a></li></ul></li><li><a class="tocitem" href="../../convergence/">Convergence checks</a></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><a class="tocitem" href="../../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Time-dependent Hamiltonian</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Time-dependent Hamiltonian</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Time-dependent-Hamiltonian"><a class="docs-heading-anchor" href="#Time-dependent-Hamiltonian">Time-dependent Hamiltonian</a><a id="Time-dependent-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-Hamiltonian" title="Permalink"></a></h1><h2 id="Context"><a class="docs-heading-anchor" href="#Context">Context</a><a id="Context-1"></a><a class="docs-heading-anchor-permalink" href="#Context" title="Permalink"></a></h2><p>To simulate a drive or a laser pulse, a time-dependent Hamiltonian is often needed. Here we explain thanks to the script in <code>MPSDynamics/examples/sbm_Htimedependent.jl</code> how this type of Hamiltonian can be integrated within the method and applied on a wavefunction. We will take a Spin-Boson Model (SBM) Hamiltonian with an Ohmic spectral density. However, the time-dependency is not model specific and can be adapated for other models. For more information about the SBM, see the dedicated example. For this example, we simulate a drive of the form</p><p class="math-container">\[        \hat{H}_\text{drive}(t) = \epsilon \hat{\sigma}_x \sin(\omega_\text{drive} t)\]</p><p>with <span>$\epsilon = \frac{2 \pi}{T_\text{Rabi}}$</span> the amplitude of the drive, <span>$T_\text{Rabi}$</span> the Rabi period, and <span>$\omega_\text{drive}$</span> the frequency of the drive. The drive is set up to be on resonance with the two-level system.</p><h2 id="The-code"><a class="docs-heading-anchor" href="#The-code">The code</a><a id="The-code-1"></a><a class="docs-heading-anchor-permalink" href="#The-code" title="Permalink"></a></h2><p>First we load the <code>MPSdynamics.jl</code> package to be able to perform the simulation, the <code>Plots.jl</code> one to plot the results, the <code>LinearAlgebra.jl</code> one to perform matrix diagonalization and the <code>LaTeXStrings.jl</code> one to be able to use <span>$\LaTeX$</span> in the plots. The function <a href="../../methods/#MPSDynamics.disp-Tuple{Any, Any, Any}"><code>MPSDynamics.disp</code></a> is also imported.</p><pre><code class="language-julia hljs">using MPSDynamics, Plots, LaTeXStrings, LinearAlgebra

import MPSDynamics: disp</code></pre><p>We then define variables for the physical parameters of the simulation. Among these, three are convergence parameters:</p><ul><li><code>d</code> is the number of states we retain for the truncated harmonic oscillators representation of environmental modes</li><li><code>N</code> is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results</li></ul><pre><code class="language-julia hljs">#----------------------------
# Physical parameters
#----------------------------

d = 4 # number of Fock states of the chain modes

N = 60 # length of the chain

α = 0.005 # coupling strength

Δ = 0.0 # tunneling 

ω0 = 0.6 # TLS gap

s = 1 # ohmicity

cpars = chaincoeffs_ohmic(N, α, s) # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0

Trabi = 30.0 # Rabi period of the drive

ϵ = 2*pi / Trabi # Intensity of the drive

ωdrive = ω0 # Frequency of the drive</code></pre><p>We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is <span>$\mathcal{O}(dt^3)$</span>. In this example we present only one-site implementation of TDVP that preserves the unitarity of the evolution:</p><ul><li>the regular one-site method with the keyword <code>:TDVP1</code> where all the virtual bonds of the MPS have the same bond dimension <span>$D$</span></li></ul><p>Logically the constant bond dimension of the MPS for TDVP1 is the respective convergence parameter.</p><pre><code class="language-julia hljs">#-----------------------
# Simulation parameters
#-----------------------

dt = 0.5 # time step

tfinal = 100.0 # simulation time

method = :TDVP1 # time-evolution method

D = [6] # MPS bond dimension</code></pre><p>We then set the time-dependent MPO. The variable <code>Ndrive</code> represents the site of the MPO where the operator of the time-dependent part acts. For this example, the two-level system is at the first site of the MPS. </p><pre><code class="language-julia hljs">#---------------------------
# MPO time-dependent
#---------------------------

timelist = collect(0:dt:tfinal)
numsteps = length(timelist)-1

#### #=
    #Example of a Ht = σ_x ϵ sin(ωdrive t) drive on the TLS
    #To comment if the example of (a+a^\dagger) drive is used

Ndrive = 1 #Number of the site on which the drive is applied. Here Ndrive=1 for the TLS
Ht = [ϵ*sx*sin(ωdrive*tstep) for tstep in timelist] # Time-dependent Hamiltonian term

#### =#</code></pre><p>The drive Hamiltonian can also be applied on several sites. The example of a Hamiltonian of the type :</p><p class="math-container">\[        \hat{H}_\text{drive}(t) = \epsilon (\hat{a}_{Ndrive} + \hat{a_{Ndrive}^\dagger}) \sin(\omega_\text{drive} t)\]</p><p>is illustrated in the following commented section. In order to drive one environment frequency, the operators have to be translated into chain operators. To try this type of driving, the previous section has to be commented.</p><pre><code class="language-julia hljs">#=
   # Example of a Ht = (a_{Ndrive_star}+a_{Ndrive_star}^\dagger) ϵ sin(ωdrive t) drive on the (Ndrive_star)th mode. 
   # The operators have to be transformed to drive the chain modes instead of the mode of the initial Hamiltonian
   # This example assumes the same dimensions for all Ndrive and that applies to a chain at the right of the system.
   # If it is not the case, the run_1TDVP loop involved when timedep=true has to be modified
   # To comment if the example of σ_x drive is used

Ndrive_star = 10
Ndrive = collect(2:N+1)

# Construct the chain Hamiltonian to write the star - chain transition matrix 
t_chain=cpars[2][1:N-1] ; e_chain=cpars[1][1:N]
hmat_chain = MPSDynamics.diagm(0=&gt;e_chain, 1=&gt;t_chain, -1=&gt;t_chain)
U_chain  = eigen(hmat_chain).vectors

print(&quot;\n Driving of the mode of frequency : &quot;,MPSDynamics.eigenchain(cpars, nummodes=N).values[Ndrive_star])

Ht = Vector{Any}(undef,N+1)

# Construct the chain operators that correspond to star operators for (a_{Ndrive_star}+a_{Ndrive_star}^\dagger
for i in Ndrive
    local anih_Ndrive = (U_chain[i-1,Ndrive_star]*anih(d))
    local crea_Ndrive = (conj(U_chain[i-1,Ndrive_star])*crea(d))
    local Ht_Ndrive = [ϵ*(anih_Ndrive+crea_Ndrive)*sin(ωdrive*tstep) for tstep in timelist]
    Ht[i] = Ht_Ndrive
end

=#</code></pre><p>Using <code>MPSDynamics.jl</code> built-in methods we define the SBM MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the &#39;local state&#39; of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.</p><p>In this part, the time-dependent terms of the MPO are stored in a list. This enables to add these terms to the MPO elements at each timestep and avoid the calculation of an entire new MPO. This way is not cumbersome since it adds a matrix sum at each time step.</p><pre><code class="language-julia hljs">#---------------------------
# MPO and initial state MPS
#---------------------------

H = spinbosonmpo(ω0, Δ, d, N, cpars) # MPO representation of the Hamiltonian

ψ = unitcol(2,2) # Initial down-z system state 

A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ&gt;|Vacuum&gt;</code></pre><p>We then choose the observables that will be stored in the data and the <a href="../../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> arguments.</p><pre><code class="language-julia hljs">#---------------------------
# Definition of observables
#---------------------------

ob1 = OneSiteObservable(&quot;sz&quot;, sz, 1)

ob2 = TwoSiteObservable(&quot;cdagc&quot;, crea(d), anih(d), collect(2:N+1), collect(2:N+1))

ob3 = TwoSiteObservable(&quot;SXdisp&quot;, sx, disp(d), [1], collect(2:N+1))
</code></pre><p><a href="../../methods/#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> is called to perform the dynamics. The argument <code>timedep</code> is set up to true and <code>Ndrive</code> and <code>Htime</code> are provided in the kwargs. </p><pre><code class="language-julia hljs">#-------------
# Simulation
#------------

A, dat = runsim(dt, tfinal, A, H;
                name = &quot;Driving field on ohmic spin boson model&quot;,
                method = method,
                obs = [ob1, ob2, ob3],
                convobs = [ob1],
                params = @LogParams(N, d, α, Δ, ω0, s),
                convparams = D,
                timedep = true, # the Hamiltonian is time dependent
                Ndrive = Ndrive, # the first site of the MPS/MPO (i.e. the system) is concerned
                Htime = Ht, # list of time-dependent terms
                verbose = false,
                save = true,
                plot = true,
                );</code></pre><p>Eventually, the stored observables can be represented. For more information about the chain observables, see <a href="../bath-observables/#Inspecting-the-bath-by-undoing-the-chain-mapping">Inspecting the bath by undoing the chain mapping</a> </p><pre><code class="language-julia hljs">
#----------
# Plots
#----------

plot(dat[&quot;data/times&quot;], dat[&quot;data/sz&quot;], label=&quot;Dmax = $(D...)&quot;, xlabel=L&quot;t&quot;,ylabel=L&quot;\sigma_z&quot;, title=&quot;&quot;)

bath_occup = mapslices(X -&gt; MPSDynamics.measuremodes(X, cpars[1], cpars[2]), dat[&quot;data/cdagc&quot;], dims = [1,2])
omeg = MPSDynamics.eigenchain(cpars, nummodes=N).values

plot(omeg, bath_occup[:, :, end], lw=4, xlabel=L&quot;\omega&quot;, ylabel=L&quot;\langle n^b_\omega \rangle&quot;,
title=&quot;Mode occupation in the extended bath at final time&quot;, legend=:none)</code></pre><p><img src="../sbm_Htime_sz.png" alt="image"/></p><p><img src="../sbm_Htime_spec.png" alt="image"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../puredephasing/">« Pure-Dephasing</a><a class="docs-footer-nextpage" href="../anderson-model/">The Anderson Impurity Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Monday 26 May 2025 13:29">Monday 26 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
